

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="xxzuo">
  <meta name="keywords" content="">
  
  <title>Flume-Sources文档(翻译中) - Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"xxzuo.github.io","root":"/","version":"1.8.9","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>xxzuo</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Flume-Sources文档(翻译中)">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      xxzuo
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-05-18 22:00" pubdate>
        2023年5月18日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      137
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Flume-Sources文档(翻译中)</h1>
            
            <div class="markdown-body">
              <h4 id="Avro-Source"><a href="#Avro-Source" class="headerlink" title="Avro Source"></a>Avro Source</h4><p>在Avro端口上监听并接收来自外部Avro客户端流的事件。当与另一个（上一跳）Flume Agent上的内置Avro Sink配对时，它可以创建分层收集拓扑。必填属性以粗体显示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Property Name</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>channels</strong></td>
<td>-</td>
<td></td>
</tr>
<tr>
<td><strong>type</strong></td>
<td>-</td>
<td>组件类型名称，需要为avro</td>
</tr>
<tr>
<td><strong>bind</strong></td>
<td>-</td>
<td>要监听的主机名或IP地址</td>
</tr>
<tr>
<td><strong>port</strong></td>
<td>-</td>
<td>要绑定到的端口号</td>
</tr>
<tr>
<td>threads</td>
<td>-</td>
<td>生成的 worker 的最大线程数量</td>
</tr>
<tr>
<td>selector.type</td>
<td></td>
<td></td>
</tr>
<tr>
<td>selector.*</td>
<td></td>
<td></td>
</tr>
<tr>
<td>interceptors</td>
<td>-</td>
<td>以空格分隔的拦截器列表</td>
</tr>
<tr>
<td>interceptors.*</td>
<td></td>
<td></td>
</tr>
<tr>
<td>compression-type</td>
<td>none</td>
<td>这可以是“none” or “deflate”。压缩类型必须与匹配Avro Source的压缩类型匹配</td>
</tr>
<tr>
<td>ssl</td>
<td>false</td>
<td>将此设置为true可启用SSL加密。如果启用了SSL，则还必须通过组件级参数（见下文）或全局SSL参数（见SSL/TLS支持部分）指定“keystore” 和 “keystore-password”。</td>
</tr>
<tr>
<td>keystore</td>
<td>-</td>
<td>这是指向 Java 密钥库文件的路径。如果没有在这里指定，则将使用全局密钥库（如果全局未定义 则会发生配置错误）。</td>
</tr>
<tr>
<td>keystore-password</td>
<td>-</td>
<td>Java密钥库的密码。如果未在此处指定，则将使用全局密钥库密码（如果全局未定义 则会发生配置错误）。</td>
</tr>
<tr>
<td>keystore-type</td>
<td>JKS</td>
<td>Java密钥库的类型。这可以是“JKS”或“PKCS12”。如果此处未指定，则将使用全局密钥存储类型（如果全局未定义 则默认为JKS）。</td>
</tr>
<tr>
<td>exclude-protocols</td>
<td>SSLv3</td>
<td>要排除的SSL/TLS协议的空格分隔列表。除了指定的协议外，SSLv3将始终被排除在外。</td>
</tr>
<tr>
<td>include-protocols</td>
<td>-</td>
<td>要包含的SSL/TLS协议的空格分隔列表。启用的协议将是包含的协议，而没有排除的协议。如果包含的协议为空，则它包括所有支持的协议。</td>
</tr>
<tr>
<td>exclude-cipher-suites</td>
<td>-</td>
<td>要排除的以空格分隔的密码套件列表。</td>
</tr>
<tr>
<td>include-cipher-suites</td>
<td>-</td>
<td>要包含的以空格分隔的密码套件列表。启用的密码套件将是包含的密码套件，而不包含排除的密码套件。如果包含的密码套件为空，则它包括所有支持的密码套件。</td>
</tr>
<tr>
<td>ipFilter</td>
<td>false</td>
<td>将此设置为true以启用netty的ipFiltering</td>
</tr>
<tr>
<td>ipFilterRules</td>
<td>-</td>
<td>使用此配置定义N个netty ipFilter模式规则。</td>
</tr>
</tbody>
</table>
</div>
<p>名为a1的 Agent 示例：<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">a1.sources</span> = <span class="hljs-string">r1</span><br><span class="hljs-meta">a1.channels</span> = <span class="hljs-string">c1</span><br><span class="hljs-meta">a1.sources.r1.type</span> = <span class="hljs-string">avro</span><br><span class="hljs-meta">a1.sources.r1.channels</span> = <span class="hljs-string">c1</span><br><span class="hljs-meta">a1.sources.r1.bind</span> = <span class="hljs-string">0.0.0.0</span><br><span class="hljs-meta">a1.sources.r1.port</span> = <span class="hljs-string">4141</span><br></code></pre></td></tr></table></figure></p>
<p>ipFilterRules 示例:<br>ipFilterRules 定义了 N 个 Netty IP 过滤器，用逗号分隔。一个模式规则必须采用下面的格式。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">&lt;’allow’ <span class="hljs-keyword">or</span> deny&gt;<span class="hljs-symbol">:&lt;</span>’ip’ <span class="hljs-keyword">or</span> ‘name’ <span class="hljs-keyword">for</span> computer name&gt;<span class="hljs-symbol">:&lt;pattern&gt;</span> <span class="hljs-keyword">or</span> allow/<span class="hljs-symbol">deny:</span>ip/<span class="hljs-symbol">name:</span>patter<br></code></pre></td></tr></table></figure><br>比如:<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">ipFilterRules</span>=<span class="hljs-string">allow:ip:127.*,allow:name:localhost,deny:ip:*</span><br></code></pre></td></tr></table></figure></p>
<p>请注意，第一个要匹配的规则将从本地主机上的客户端应用，如下例所示<br>这将允许本地主机上的客户端,拒绝来自任何其他ip的客户端</p>
<blockquote>
<p>allow:name:localhost,deny:ip:</p>
</blockquote>
<p>这将拒绝本地主机上的客户端,允许来自任何其他ip的客户端</p>
<blockquote>
<p>deny:name:localhost,allow:ip:</p>
</blockquote>
<h4 id="Thrift-Source"><a href="#Thrift-Source" class="headerlink" title="Thrift Source"></a>Thrift Source</h4><p>监听 Thrift 端口并接收来自外部 Thrift 客户端流的事件。当与另一个（上一跳）Flume Agent上的内置 ThriftSink 配对时，它可以创建分层集合拓扑。通过启用kerberos身份验证，可以将Thrift Source 配置为以安全模式启动。agent-principal 和 agent-keytab 是Thrift Source 用来向kerberos KDC进行身份验证的属性。必填属性以粗体显示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Property Name</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>channels</strong></td>
<td>-</td>
<td></td>
</tr>
<tr>
<td><strong>type</strong></td>
<td>-</td>
<td>组件类型名称，需要为thrift</td>
</tr>
<tr>
<td><strong>bind</strong></td>
<td>-</td>
<td>要监听的主机名或IP地址</td>
</tr>
<tr>
<td><strong>port</strong></td>
<td>-</td>
<td>要绑定到的端口号</td>
</tr>
<tr>
<td>threads</td>
<td>-</td>
<td>生成的 worker 的最大线程数量</td>
</tr>
<tr>
<td>selector.type</td>
<td></td>
<td></td>
</tr>
<tr>
<td>selector.*</td>
<td></td>
<td></td>
</tr>
<tr>
<td>interceptors</td>
<td>-</td>
<td>以空格分隔的拦截器列表</td>
</tr>
<tr>
<td>interceptors.*</td>
<td></td>
<td></td>
</tr>
<tr>
<td>compression-type</td>
<td>none</td>
<td>这可以是“none” or “deflate”。压缩类型必须与匹配Avro Source的压缩类型匹配</td>
</tr>
<tr>
<td>ssl</td>
<td>false</td>
<td>将此设置为true可启用SSL加密。如果启用了SSL，则还必须通过组件级参数（见下文）或全局SSL参数（见SSL/TLS支持部分 [[flume User Guide(1.11)#^cf1b41\</td>
<td>ssl/tls]]）指定“keystore” 和 “keystore-password”。</td>
</tr>
<tr>
<td>keystore</td>
<td>-</td>
<td>这是指向 Java 密钥库文件的路径。如果没有在这里指定，则将使用全局密钥库（如果全局未定义 则会发生配置错误）。</td>
</tr>
<tr>
<td>keystore-password</td>
<td>-</td>
<td>Java密钥库的密码。如果未在此处指定，则将使用全局密钥库密码（如果全局未定义 则会发生配置错误）。</td>
</tr>
<tr>
<td>keystore-type</td>
<td>JKS</td>
<td>Java密钥库的类型。这可以是“JKS”或“PKCS12”。如果此处未指定，则将使用全局密钥存储类型（如果全局未定义 则默认为JKS）。</td>
</tr>
<tr>
<td>exclude-protocols</td>
<td>SSLv3</td>
<td>要排除的SSL/TLS协议的空格分隔列表。除了指定的协议外，SSLv3将始终被排除在外。</td>
</tr>
<tr>
<td>include-protocols</td>
<td>-</td>
<td>要包含的SSL/TLS协议的空格分隔列表。启用的协议将是包含的协议，而没有排除的协议。如果包含的协议为空，则它包括所有支持的协议。</td>
</tr>
<tr>
<td>exclude-cipher-suites</td>
<td>-</td>
<td>要排除的以空格分隔的密码套件列表。</td>
</tr>
<tr>
<td>include-cipher-suites</td>
<td>-</td>
<td>要包含的以空格分隔的密码套件列表。启用的密码套件将是包含的密码套件，而不包含排除的密码套件。如果包含的密码套件为空，则它包括所有支持的密码套件。</td>
</tr>
<tr>
<td>kerberos</td>
<td>false</td>
<td>设置为true可启用kerberos身份验证。在kerberos模式下，成功的身份验证需要 agent-principal 和 agent-keytab 。安全模式下的Thrift Source将只接受来自启用了kerberos并成功通过kerberos KDC身份验证的Thrift客户端的连接。</td>
</tr>
<tr>
<td>agent-principal</td>
<td>-</td>
<td>Thrift Source用于向kerberos KDC进行身份验证的kerberos主体。</td>
</tr>
<tr>
<td>agent-keytab</td>
<td>-</td>
<td>Thrift Source与 agent-principal 结合使用的keytab location，用于向kerberos KDC进行身份验证。</td>
</tr>
</tbody>
</table>
</div>
<p>名为a1的 Agent 示例：<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">a1.sources</span> = <span class="hljs-string">r1</span><br><span class="hljs-meta">a1.channels</span> = <span class="hljs-string">c1</span><br><span class="hljs-meta">a1.sources.r1.type</span> = <span class="hljs-string">thrift</span><br><span class="hljs-meta">a1.sources.r1.channels</span> = <span class="hljs-string">c1</span><br><span class="hljs-meta">a1.sources.r1.bind</span> = <span class="hljs-string">0.0.0.0</span><br><span class="hljs-meta">a1.sources.r1.port</span> = <span class="hljs-string">4141</span><br></code></pre></td></tr></table></figure></p>
<h4 id="Exec-Source"><a href="#Exec-Source" class="headerlink" title="Exec Source"></a>Exec Source</h4><p>Exec source 在启动时运行给定的 Unix 命令，并期望该进程不断在标准输出上产生数据（除非将属性 logStdErr 设置为 true，否则 stderr 将被简单地丢弃）。如果进程因任何原因退出，则源也会退出，并且不会再产生数据。<br>这意味着像 <code>cat [named pipe]</code> 或 <code>tail -F [file]</code> 这样的配置将产生预期的结果，而 <code>date</code> 可能不会。<br>前两个命令产生数据流，而后者产生单个事件然后退出。<br>必需的属性以粗体显示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Property Name</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>channels</strong></td>
<td>-</td>
<td></td>
</tr>
<tr>
<td><strong>type</strong></td>
<td>-</td>
<td>组件类型名称，需要为thrift</td>
</tr>
<tr>
<td><strong>command</strong></td>
<td>-</td>
<td>要监听的主机名或IP地址</td>
</tr>
<tr>
<td>shell</td>
<td>-</td>
<td>用于运行命令的shell调用。例如/bin/sh-c。仅对于依赖于外壳程序功能（如通配符、反勾号、管道等）的命令是必需的。</td>
</tr>
<tr>
<td>restartThrottle</td>
<td>10000</td>
<td>尝试重新启动之前等待的时间（以毫秒为单位）</td>
</tr>
<tr>
<td>restart</td>
<td>false</td>
<td>如果执行的cmd死了，是否应该重新启动 。</td>
</tr>
<tr>
<td>logStdErr</td>
<td>false</td>
<td>是否应记录命令的stderr</td>
</tr>
<tr>
<td>batchSize</td>
<td>20</td>
<td>一次读取并发送到通道的最大行数</td>
</tr>
<tr>
<td>batchTimeout</td>
<td>3000</td>
<td>如果未达到缓冲区大小，则在数据被向下推送之前等待的时间（以毫秒为单位）</td>
</tr>
<tr>
<td>selector.type</td>
<td>replicating</td>
<td>复制或多路传输</td>
</tr>
<tr>
<td>selector.*</td>
<td></td>
<td>取决于 selector.type的值</td>
</tr>
<tr>
<td>interceptors</td>
<td>-</td>
<td>以空格分隔的拦截器列表</td>
</tr>
<tr>
<td>interceptors.*</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>Warning</strong><br>ExecSource 和其他异步 Source 的问题在于，Source 不能保证如果将事件放入 Channel 失败，客户端就知道了。在这种情况下，数据将会丢失。例如，最常见的请求之一是类似于 <code>tail -F [file]</code> 的用例，其中应用程序将数据写入磁盘上的日志文件，而 Flume 会跟踪文件，将每行作为一个事件发送。虽然这是可能的，但存在一个明显的问题；如果 Channel 填满，Flume 就无法发送事件了，怎么办？Flume 没有办法向写日志文件的应用程序表明它需要保留日志或者由于某种原因没有发送事件。如果这听起来没有意义，你只需要知道：使用单向异步接口（如 ExecSource）时，您的应用程序永远无法保证数据已被接收！<br>作为这个警告的扩展 - 为了完全清楚 - 当使用这个源时，绝对没有事件传递的保证。<br>为了更强的可靠性保证.<br>请考虑使用 Spooling Directory Source、Taildir Source 或通过 SDK 直接与 Flume 进行集成。</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">a1.sources</span> = <span class="hljs-string">r1</span><br><span class="hljs-meta">a1.channels</span> = <span class="hljs-string">c1</span><br><span class="hljs-meta">a1.sources.r1.type</span> = <span class="hljs-string">exec</span><br><span class="hljs-meta">a1.sources.r1.command</span> = <span class="hljs-string">tail -F /var/log/secure</span><br><span class="hljs-meta">a1.sources.r1.channels</span> = <span class="hljs-string">c1</span><br></code></pre></td></tr></table></figure>
<p>“shell”配置用于通过命令shell（如Bash或Powershell）调用“command”。“command”作为参数传递给“shell”以执行。这允许“命令”使用shell的功能，如通配符、反勾号、管道、循环、条件等。在没有“shell”配置的情况下，将直接调用“command”。“shell”的常见值：‘/bin/sh -c’, ‘/bin/ksh -c’, ‘cmd /c’, ‘powershell -Command’等。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">a1.sources.tailsource-1.type</span> = <span class="hljs-string">exec</span><br><span class="hljs-meta">a1.sources.tailsource-1.shell</span> = <span class="hljs-string">/bin/bash -c</span><br><span class="hljs-meta">a1.sources.tailsource-1.command</span> = <span class="hljs-string">for i in /path/*.txt; do cat $i; done</span><br></code></pre></td></tr></table></figure>
<h4 id="JMS-Source"><a href="#JMS-Source" class="headerlink" title="JMS Source"></a>JMS Source</h4><p>JMS Source 从JMS目标（如队列或主题）读取消息。作为JMS应用程序，它应该与任何JMS提供程序一起工作，但仅在 ActiveMQ 中进行了测试。JMS Source 提供可配置的批大小、消息选择器、用户/传递和消息到 flume event 转换器。请注意，供应商提供的JMS jar应该使用<code>plugins.d</code> 目录（首选）、命令行上的 <code>–classpath</code> 或通过<code>flume-env.sh</code>中的<code>FLUME_CLASSPATH</code>变量包含在Flume classpath中。</p>
<p>所需属性以粗体显示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Property Name</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>channels</strong></td>
<td>-</td>
<td></td>
</tr>
<tr>
<td><strong>type</strong></td>
<td>-</td>
<td>组件类型名称，需要为 <code>jms</code></td>
</tr>
<tr>
<td><strong>initialContextFactory</strong></td>
<td>-</td>
<td>初始上下文工厂,例如:org.apache.activemq.jndi.ActiveMQInitialContextFactory</td>
</tr>
<tr>
<td><strong>connectionFactory</strong></td>
<td>-</td>
<td>连接工厂应该出现的JNDI名称</td>
</tr>
<tr>
<td><strong>providerURL</strong></td>
<td>-</td>
<td>JMS提供者URL</td>
</tr>
<tr>
<td><strong>destinationName</strong></td>
<td>-</td>
<td>目标名称</td>
</tr>
<tr>
<td><strong>destinationType</strong></td>
<td>-</td>
<td>目标类型(队列或主题)</td>
</tr>
<tr>
<td>messageSelector</td>
<td>-</td>
<td>创建消费者时使用的消息选择器</td>
</tr>
<tr>
<td>userName</td>
<td>-</td>
<td>目的地/提供者的用户名</td>
</tr>
<tr>
<td>passwordFile</td>
<td>-</td>
<td>包含目的地/提供者密码的文件</td>
</tr>
<tr>
<td>batchSize</td>
<td>100</td>
<td>一批消费中的消息数量</td>
</tr>
<tr>
<td>converter.type</td>
<td>DEFAULT</td>
<td>用于将消息转换为 Flume 事件的类。 见下文。</td>
</tr>
<tr>
<td>converter.*</td>
<td>-</td>
<td>转换器属性。</td>
</tr>
<tr>
<td>converter.charset</td>
<td>UTF-8</td>
<td>仅默认转换器。 将 JMS TextMessage 转换为字节数组时要使用的字符集。</td>
</tr>
<tr>
<td>createDurableSubscription</td>
<td>false</td>
<td>是否创建持久订阅。 持久订阅只能与destinationType 主题一起使用。 如果为 true，则必须指定“clientId”和“durableSubscriptionName”</td>
</tr>
<tr>
<td>clientId</td>
<td>-</td>
<td>创建连接后立即在连接上设置 JMS 客户端标识符。 持久订阅所需</td>
</tr>
<tr>
<td>durableSubscriptionName</td>
<td>-</td>
<td>用于标识持久订阅的名称。 持久订阅所必需的。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="JMS-message-converter"><a href="#JMS-message-converter" class="headerlink" title="JMS message converter"></a>JMS message converter</h5><p>JMS source允许可插拔的转换器,尽管默认的转换器对大多数目的来说可能已经足够。默认转换器能够将Bytes、Text和Object消息转换为FlumeEvent。在所有情况下,消息中的属性都被添加为FlumeEvent的header。</p>
<ul>
<li><p>BytesMessage:<br>消息的字节被复制到FlumeEvent的body中。每条消息无法转换超过2GB的数据。</p>
</li>
<li><p>TextMessage:<br>消息文本被转换为字节数组并复制到FlumeEvent的body中。默认使用UTF-8编码但可以配置。</p>
</li>
<li><p>ObjectMessage:<br>对象被写入到包装在ObjectOutputStream中的ByteArrayOutputStream中,结果数组被复制到FlumeEvent的body中。</p>
</li>
</ul>
<p>名为 a1 的代理示例：<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">a1.sources</span> = <span class="hljs-string">r1</span><br><span class="hljs-meta">a1.channels</span> = <span class="hljs-string">c1</span><br><span class="hljs-meta">a1.sources.r1.type</span> = <span class="hljs-string">jms</span><br><span class="hljs-meta">a1.sources.r1.channels</span> = <span class="hljs-string">c1</span><br><span class="hljs-meta">a1.sources.r1.initialContextFactory</span> = <span class="hljs-string">org.apache.activemq.jndi.ActiveMQInitialContextFactory</span><br><span class="hljs-meta">a1.sources.r1.connectionFactory</span> = <span class="hljs-string">GenericConnectionFactory</span><br><span class="hljs-meta">a1.sources.r1.providerURL</span> = <span class="hljs-string">tcp://mqserver:61616</span><br><span class="hljs-meta">a1.sources.r1.destinationName</span> = <span class="hljs-string">BUSINESS_DATA</span><br><span class="hljs-meta">a1.sources.r1.destinationType</span> = <span class="hljs-string">QUEUE</span><br></code></pre></td></tr></table></figure></p>
<h5 id="SSL-and-JMS-Source"><a href="#SSL-and-JMS-Source" class="headerlink" title="SSL and JMS Source"></a>SSL and JMS Source</h5><p>JMS客户端实现通常支持通过JSSE(Java Secure Socket Extension)定义的一些Java系统属性来配置SSL/TLS。</p>
<p>为Flume的JVM指定这些系统属性,JMS Source(或者更精确地说,JMS Source使用的JMS客户端实现)可以通过SSL连接到JMS服务器(当然,前提是JMS服务器也被设置为使用SSL)。</p>
<p>这应该适用于任何JMS提供商,并且已经在ActiveMQ、IBM MQ和Oracle WebLogic上进行了测试。</p>
<p>以下部分仅描述Flume一侧所需的SSL配置步骤。您可以在Flume Wiki上找到有关不同JMS提供商的服务器端设置的更详细描述以及完整的工作配置示例。</p>
<p><strong>SSL transport / server authentication:</strong></p>
<p>如果JMS服务器使用自签名证书或其证书由不可信的CA签名(例如公司自己的CA),则需要设置truststore(包含正确的证书)并传递给Flume。这可以通过全局SSL参数来完成。有关全局SSL设置的更多详细信息,请参阅SSL/TLS支持部分 [[flume User Guide(1.11)#^cf1b41|ssl/tls]]。</p>
<p>某些JMS提供商在使用SSL时需要特定于SSL的JNDI初始上下文工厂和/或提供商URL设置(例如,ActiveMQ使用ssl:// URL前缀而不是tcp://)。在这种情况下,必须在代理配置文件中调整source属性(initialContextFactory和/或providerURL)。</p>
<p><strong>Client certificate authentication (two-way SSL) 客户端证书认证（双向SSL）:</strong> </p>
<p>JMS Source可以通过客户端证书认证而不是通常的用户名/密码登录来向JMS服务器进行认证(当使用SSL且JMS服务器被配置为接受此类认证时)。</p>
<p>包含Flume用于认证的密钥的keystore需要再次通过全局SSL参数进行配置。有关全局SSL设置的详细信息,请参阅SSL/TLS支持部分 [[flume User Guide(1.11)#^cf1b41|ssl/tls]]。</p>
<p>keystore应该只包含一个密钥(如果存在多个密钥,则将使用第一个密钥)。密钥密码必须与keystore密码相同。</p>
<p>在客户端证书认证的情况下,无需在Flume代理配置文件中为JMS Source指定userName/passwordFile属性。</p>
<p><strong>请注意:</strong><br>与其他组件不同，JMS Source 没有组件级配置参数。 也没有启用 SSL 标志。 SSL 设置由 JNDI/Provider URL 设置（最终是 JMS 服务器设置）以及信任库/密钥库的存在/不存在控制。</p>
<h4 id="Spooling-Directory-Source"><a href="#Spooling-Directory-Source" class="headerlink" title="Spooling Directory Source"></a>Spooling Directory Source</h4><p>这个source允许您通过将要摄取的文件放入磁盘上的“池”目录来摄取数据。此source将监视指定的目录以获取新文件,并在出现新文件时从中解析事件。事件解析逻辑是可插拔的。在完全读入通道后,默认情况下,通过重命名文件或删除文件或使用trackerDir来跟踪已处理文件来指示完成。</p>
<p>与Exec source不同,此source是可靠的,即使Flume重新启动或被杀死,也不会丢失数据。为了换取这种可靠性,只能将不可变的、唯一命名的文件放入池目录中。Flume会试图检测这些问题条件,如果违反这些条件,会发出很大的错误提示:</p>
<ol>
<li>如果在放入池目录后文件被写入,Flume将向其日志文件打印错误并停止处理。</li>
<li>如果后来重用了文件名,Flume将向其日志文件打印错误并停止处理。</li>
</ol>
<p>为了避免上述问题,当日志文件被移动到池目录中时,可以考虑在日志文件名中添加唯一标识符(如时间戳)。</p>
<p>尽管此source提供了可靠性保证,但如果某些下游失败发生,事件可能会被复制。这与其他Flume组件提供的保证一致。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Property Name</th>
<th>Default</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>channels</strong></td>
<td>–</td>
<td></td>
</tr>
<tr>
<td><strong>type</strong></td>
<td>–</td>
<td>组件类型名称,需要为spooldir</td>
</tr>
<tr>
<td><strong>spoolDir</strong></td>
<td>–</td>
<td>读取文件目录路径</td>
</tr>
<tr>
<td>fileSuffix</td>
<td>.COMPLETED</td>
<td>完全摄取文件的后缀</td>
</tr>
<tr>
<td>deletePolicy</td>
<td>never</td>
<td>完成文件删除策略:never 或 immediate</td>
</tr>
<tr>
<td>fileHeader</td>
<td>false</td>
<td>是否添加头保存完整文件名</td>
</tr>
<tr>
<td>fileHeaderKey</td>
<td>file</td>
<td>文件名添加到 event header 的键</td>
</tr>
<tr>
<td>basenameHeader</td>
<td>false</td>
<td>是否添加头保存文件名</td>
</tr>
<tr>
<td>basenameHeaderKey</td>
<td>basename</td>
<td>文件名添加到 event header 的键</td>
</tr>
<tr>
<td>includePattern</td>
<td>^.*$</td>
<td>指定包含哪些文件正则表达式。可以与ignorePattern一起使用。如果文件同时匹配ignorePattern和includePattern则忽略。</td>
</tr>
<tr>
<td>ignorePattern</td>
<td>^$</td>
<td>指定忽略哪些文件的正则表达式。可以与includePattern一起使用。如果文件同时匹配ignorePattern和includePattern则忽略。</td>
</tr>
<tr>
<td>trackerDir</td>
<td>.flumespool</td>
<td>存储文件处理元数据的目录。如果不是绝对路径,则相对于spoolDir。</td>
</tr>
<tr>
<td>trackingPolicy</td>
<td>rename</td>
<td>定义文件处理追踪策略。可以是“rename”或“tracker_dir”。仅在deletePolicy为“never”时有效。“rename” - 处理后根据fileSuffix重命名文件。“tracker_dir” - 文件不重命名,在trackerDir中创建一个空文件。新tracker文件名基于摄取文件名加上fileSuffix。</td>
</tr>
<tr>
<td>consumeOrder</td>
<td>oldest</td>
<td>池目录中文件消费顺序:oldest最旧,youngest最新,random随机。oldest和youngest基于最后修改时间比较。random完全随机选择。oldest和youngest需全目录扫描选择最旧/最新文件,如果大量文件效率低;random可能导致旧文件被延后消费。</td>
</tr>
<tr>
<td>pollDelay</td>
<td>500</td>
<td>轮询新文件的延迟(毫秒)</td>
</tr>
<tr>
<td>recursiveDirectorySearch</td>
<td>false</td>
<td>是否监控子目录的新文件</td>
</tr>
<tr>
<td>maxBackoff</td>
<td>4000</td>
<td>写入channel失败的最大退避时间(毫秒)。从低backoff指数增加到配置值。</td>
</tr>
<tr>
<td>batchSize</td>
<td>100</td>
<td>批量传输到channel的粒度</td>
</tr>
<tr>
<td>inputCharset</td>
<td>UTF-8</td>
<td>处理文本文件时使用的字符集</td>
</tr>
<tr>
<td>decodeErrorPolicy</td>
<td>FAIL</td>
<td>发现不可解码字符时的处理策略。FAIL:抛异常失败;REPLACE:替换为特殊未知字符;IGNORE:忽略</td>
</tr>
<tr>
<td>deserializer</td>
<td>LINE</td>
<td>解析文件到事件的反序列化器。默认逐行解析。必须实现EventDeserializer.Builder。</td>
</tr>
<tr>
<td>deserializer.*</td>
<td></td>
<td>因反序列化器而异</td>
</tr>
<tr>
<td>bufferMaxLines</td>
<td>–</td>
<td>(废弃)现在忽略</td>
</tr>
<tr>
<td>bufferMaxLineLength</td>
<td>5000</td>
<td>(废弃)替代为deserializer.maxLineLength</td>
</tr>
<tr>
<td>selector.type</td>
<td>replicating</td>
<td>复制或复用</td>
</tr>
<tr>
<td>selector.*</td>
<td></td>
<td>依赖selector.type值</td>
</tr>
<tr>
<td>interceptors</td>
<td>–</td>
<td>空格分隔拦截器列表</td>
</tr>
<tr>
<td>interceptors.*</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>名为 a1 的代理示例：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">a1.channels</span> = <span class="hljs-string">ch-1</span><br><span class="hljs-meta">a1.sources</span> = <span class="hljs-string">src-1</span><br><br><span class="hljs-meta">a1.sources.src-1.type</span> = <span class="hljs-string">spooldir</span><br><span class="hljs-meta">a1.sources.src-1.channels</span> = <span class="hljs-string">ch-1</span><br><span class="hljs-meta">a1.sources.src-1.spoolDir</span> = <span class="hljs-string">/var/log/apache/flumeSpool</span><br><span class="hljs-meta">a1.sources.src-1.fileHeader</span> = <span class="hljs-string">true</span><br></code></pre></td></tr></table></figure>
<h5 id="Event-Deserializers"><a href="#Event-Deserializers" class="headerlink" title="Event Deserializers"></a>Event Deserializers</h5><p>Flume 附带以下事件反序列化器。</p>
<h6 id="LINE"><a href="#LINE" class="headerlink" title="LINE"></a>LINE</h6><p>这个反序列化器针对每行文本输入生成一个事件。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Property Name</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>deserializer.maxLineLength</td>
<td>2048</td>
<td>单个事件中包含的最大字符数。 如果一行超过此长度，则会被截断，并且该行中剩余的字符将出现在后续事件中。</td>
</tr>
<tr>
<td>deserializer.outputCharset</td>
<td>UTF-8</td>
<td>用于对放入 channel 的事件进行编码的字符集。</td>
</tr>
</tbody>
</table>
</div>
<h6 id="AVRO"><a href="#AVRO" class="headerlink" title="AVRO"></a>AVRO</h6><p>这个反序列化器能够读取Avro容器文件,并对文件中的每条Avro记录生成一个事件。每个事件都带有一个标头,指示使用的模式。事件的body是二进制的Avro记录数据,不包括schema或容器文件中的其他元素。</p>
<p>注意,如果spool目录源必须重试将这些事件之一放到通道上(例如,因为通道已满),那么它将重置并从最新的Avro容器文件同步点重试。为了减少这种失败场景中的潜在事件重复,可以在Avro输入文件中更频繁地写入同步标记。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Property Name</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>deserializer.schemaType</td>
<td>HASH</td>
<td>架构的表示方式。 默认情况下，或者当指定 HASH 值时，Avro 架构会进行哈希处理，并且哈希值存储在事件标头“flume.avro.schema.hash”中的每个事件中。 如果指定了 LITERAL，则 JSON 编码的架构本身存储在事件标头“flume.avro.schema.literal”中的每个事件中。 与 HASH 模式相比，使用 Literal 模式的效率相对较低。</td>
</tr>
</tbody>
</table>
</div>
<h6 id="BlobDeserializer"><a href="#BlobDeserializer" class="headerlink" title="BlobDeserializer"></a>BlobDeserializer</h6><p>此反序列化器针对每个事件读取一个二进制大对象 (BLOB)，通常每个文件读取一个 BLOB。 例如 PDF 或 JPG 文件。 请注意，此方法不适合非常大的对象，因为整个 BLOB 都缓冲在 RAM 中。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Property Name</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>deserializer</strong></td>
<td>–</td>
<td>这个类的完全限定类名: org.apache.flume.sink.solr.morphline.BlobDeserializer$Builder</td>
</tr>
<tr>
<td>deserializer.maxBlobLength</td>
<td>100000000</td>
<td>针对给定请求读取和缓冲的最大字节数</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Taildir-Source"><a href="#Taildir-Source" class="headerlink" title="Taildir Source"></a>Taildir Source</h4><blockquote>
<p><strong>注意 此源作为预览功能提供。 它不适用于 Windows。</strong></p>
</blockquote>
<p>监视指定的文件,在检测到每份文件中追加了新行时,几乎实时地对其进行尾部跟踪。如果新行正在被写入,此source将重试读取以等待写入完成。</p>
<p>此source是可靠的,即使尾部文件的轮换也不会丢失数据。它会定期以JSON格式将每个文件的最后读取位置写入指定的位置文件。如果Flume停止或由于某些原因关闭,它可以从现有位置文件中写入的位置重新开始尾部跟踪。</p>
<p>在其他用例中,此source还可以使用给定的位置文件从每个文件的任意位置开始尾部跟踪。如果在指定路径上没有位置文件,它将默认从每个文件的第一行开始跟踪。</p>
<p>文件将按修改时间顺序进行消费。修改时间最早的文件将首先被消费。</p>
<p>此source不会重命名、删除或修改被跟踪的文件。当前此source不支持尾部跟踪二进制文件。它逐行读取文本文件。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Property Name</th>
<th>Default</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>channels</strong></td>
<td>–</td>
<td></td>
</tr>
<tr>
<td><strong>type</strong></td>
<td>–</td>
<td>组件类型名称,需要为TAILDIR</td>
</tr>
<tr>
<td><strong>filegroups</strong></td>
<td>–</td>
<td>空格分隔的文件组列表。每个文件组表示一组要tailed的文件</td>
</tr>
<tr>
<td><strong>filegroups.\<filegroupName></strong></td>
<td>–</td>
<td>文件组的绝对路径。文件名只能使用正则表达式(而不是文件系统通配符)</td>
</tr>
<tr>
<td>positionFile</td>
<td>~/.flume/taildir_position.json</td>
<td>记录每个tailed文件inode、路径和最后位置的JSON格式文件</td>
</tr>
<tr>
<td>headers.\<filegroupName>.\<headerKey></td>
<td>–</td>
<td>设置具有header key的header值。每个file group可以指定多个header</td>
</tr>
<tr>
<td>byteOffsetHeader</td>
<td>false</td>
<td>是否在名为“byteoffset”的标头中添加tailed行的字节偏移量</td>
</tr>
<tr>
<td>skipToEnd</td>
<td>false</td>
<td>如果位置文件中没有写入,是否跳过到EOF的位置</td>
</tr>
<tr>
<td>idleTimeout</td>
<td>120000</td>
<td>关闭不活动文件的时间(毫秒)。如果该文件有新行追加,源会自动重新打开</td>
</tr>
<tr>
<td>writePosInterval</td>
<td>3000</td>
<td>写入每个文件最后位置到位置文件的时间间隔(毫秒)</td>
</tr>
<tr>
<td>batchSize</td>
<td>100</td>
<td>每次读取和发送到channel的最大行数。默认通常就好</td>
</tr>
<tr>
<td>maxBatchCount</td>
<td>Long.MAX_VALUE</td>
<td>从同一文件中连续读取的批处理数的控制。如果源正在跟踪多个文件,并且其中一个以更快的速率写入,则可能会阻止处理其他文件,因为繁忙文件的读取将无限循环。在这种情况下,降低此值</td>
</tr>
<tr>
<td>backoffSleepIncrement</td>
<td>1000</td>
<td>在上一次尝试未找到新数据时,重试轮询新数据之前的延迟递增时间</td>
</tr>
<tr>
<td>maxBackoffSleep</td>
<td>5000</td>
<td>在上一次尝试未找到新数据时,每次重试轮询新数据之间的最大延迟时间</td>
</tr>
<tr>
<td>cachePatternMatching</td>
<td>true</td>
<td>列出目录和应用文件名正则表达式匹配可能非常耗时,如果目录中包含数千个文件。缓存匹配文件的列表可以提高性能。消费文件的顺序也会被缓存。要求文件系统以至少1秒的粒度跟踪修改时间</td>
</tr>
<tr>
<td>fileHeader</td>
<td>false</td>
<td>是否添加一个标头存储完整文件名</td>
</tr>
<tr>
<td>fileHeaderKey</td>
<td>file</td>
<td>追加绝对文件名到事件标头时使用的标头键</td>
</tr>
</tbody>
</table>
</div>
<p>名为 a1 的代理示例：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">a1.sources</span> = <span class="hljs-string">r1</span><br><span class="hljs-meta">a1.channels</span> = <span class="hljs-string">c1</span><br><span class="hljs-meta">a1.sources.r1.type</span> = <span class="hljs-string">TAILDIR</span><br><span class="hljs-meta">a1.sources.r1.channels</span> = <span class="hljs-string">c1</span><br><span class="hljs-meta">a1.sources.r1.positionFile</span> = <span class="hljs-string">/var/log/flume/taildir_position.json</span><br><span class="hljs-meta">a1.sources.r1.filegroups</span> = <span class="hljs-string">f1 f2</span><br><span class="hljs-meta">a1.sources.r1.filegroups.f1</span> = <span class="hljs-string">/var/log/test1/example.log</span><br><span class="hljs-meta">a1.sources.r1.headers.f1.headerKey1</span> = <span class="hljs-string">value1</span><br><span class="hljs-meta">a1.sources.r1.filegroups.f2</span> = <span class="hljs-string">/var/log/test2/.*log.*</span><br><span class="hljs-meta">a1.sources.r1.headers.f2.headerKey1</span> = <span class="hljs-string">value2</span><br><span class="hljs-meta">a1.sources.r1.headers.f2.headerKey2</span> = <span class="hljs-string">value2-2</span><br><span class="hljs-meta">a1.sources.r1.fileHeader</span> = <span class="hljs-string">true</span><br><span class="hljs-meta">a1.sources.ri.maxBatchCount</span> = <span class="hljs-string">1000</span><br></code></pre></td></tr></table></figure>
<h4 id="Twitter-1-firehose-Source-experimental"><a href="#Twitter-1-firehose-Source-experimental" class="headerlink" title="Twitter 1% firehose Source (experimental)"></a>Twitter 1% firehose Source (experimental)</h4><blockquote>
<p><strong>警告: 此源是高度实验性的，可能会在 Flume 的次要版本之间发生变化。 使用风险自负。</strong></p>
</blockquote>
<p>通过 Streaming API 连接到 1% 样本 twitter firehose 的实验源，持续下载推文，将其转换为 Avro 格式并将 Avro 事件发送到下游 Flume 接收器。 需要 Twitter 开发者帐户的消费者和访问令牌和秘密。 必需的属性以粗体显示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Property Name</th>
<th>Default</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>channels</strong></td>
<td>–</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>type</strong></td>
<td>–</td>
<td>组件类型名称，需要是 <code>org.apache.flume.source.twitter.TwitterSource</code></td>
<td></td>
</tr>
<tr>
<td><strong>consumerKey</strong></td>
<td>–</td>
<td>OAuth consumer key</td>
<td></td>
</tr>
<tr>
<td><strong>consumerSecret</strong></td>
<td>–</td>
<td>OAuth consumer secret</td>
<td></td>
</tr>
<tr>
<td><strong>accessToken</strong></td>
<td>–</td>
<td>OAuth access token</td>
<td></td>
</tr>
<tr>
<td><strong>accessTokenSecret</strong></td>
<td>–</td>
<td>OAuth token secret</td>
<td></td>
</tr>
<tr>
<td>maxBatchSize</td>
<td>1000</td>
<td>单个批次中放入的 Twitter 消息的最大数量</td>
<td></td>
</tr>
<tr>
<td>maxBatchDurationMillis</td>
<td>1000</td>
<td>关闭批次之前等待的最大毫秒数</td>
</tr>
</tbody>
</table>
</div>
<p>名为 a1 的代理示例：<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">a1.sources</span> = <span class="hljs-string">r1</span><br><span class="hljs-meta">a1.channels</span> = <span class="hljs-string">c1</span><br><span class="hljs-meta">a1.sources.r1.type</span> = <span class="hljs-string">org.apache.flume.source.twitter.TwitterSource</span><br><span class="hljs-meta">a1.sources.r1.channels</span> = <span class="hljs-string">c1</span><br><span class="hljs-meta">a1.sources.r1.consumerKey</span> = <span class="hljs-string">YOUR_TWITTER_CONSUMER_KEY</span><br><span class="hljs-meta">a1.sources.r1.consumerSecret</span> = <span class="hljs-string">YOUR_TWITTER_CONSUMER_SECRET</span><br><span class="hljs-meta">a1.sources.r1.accessToken</span> = <span class="hljs-string">YOUR_TWITTER_ACCESS_TOKEN</span><br><span class="hljs-meta">a1.sources.r1.accessTokenSecret</span> = <span class="hljs-string">YOUR_TWITTER_ACCESS_TOKEN_SECRET</span><br><span class="hljs-meta">a1.sources.r1.maxBatchSize</span> = <span class="hljs-string">10</span><br><span class="hljs-meta">a1.sources.r1.maxBatchDurationMillis</span> = <span class="hljs-string">200</span><br><br></code></pre></td></tr></table></figure></p>
<h4 id="Kafka-Source"><a href="#Kafka-Source" class="headerlink" title="Kafka Source"></a>Kafka Source</h4><p>Kafka Source 是一个 Apache Kafka 消费者，它从 Kafka 主题读取消息。 如果您有多个 Kafka Source 正在运行，您可以使用相同的 Consumer Group 配置它们，这样每个源都会读取一组唯一的主题分区。 目前支持 Kafka 服务器版本 0.10.1.0 或更高版本。 测试已完成至 2.0.1，这是发布时的最高可用版本。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性名称</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>channels</strong></td>
<td>–</td>
<td></td>
</tr>
<tr>
<td><strong>type</strong></td>
<td>–</td>
<td>组件类型名称,需要为 org.apache.flume.source.kafka.KafkaSource</td>
</tr>
<tr>
<td><strong>kafka.bootstrap.servers</strong></td>
<td>–</td>
<td>源使用的Kafka集群中代理的列表</td>
</tr>
<tr>
<td>kafka.consumer.group.id</td>
<td>flume</td>
<td>消费者组的唯一标识。在多个源或代理中设置相同ID表示它们属于同一个消费者组</td>
</tr>
<tr>
<td><strong>kafka.topics</strong></td>
<td>–</td>
<td>Kafka消费者将读取消息的主题列表,以逗号分隔。</td>
</tr>
<tr>
<td><strong>kafka.topics.regex</strong></td>
<td>–</td>
<td>定义源订阅的主题集的正则表达式。此属性的优先级高于kafka.topics,如果存在则会覆盖kafka.topics。</td>
</tr>
<tr>
<td>batchSize</td>
<td>1000</td>
<td>一次批量写到Channel中的消息的最大数量</td>
</tr>
<tr>
<td>batchDurationMillis</td>
<td>1000</td>
<td>在批处理被写入Channel之前的最大时间(毫秒)。无论大小还是时间达到的先决条件,批处理都将被写入。</td>
</tr>
<tr>
<td>backoffSleepIncrement</td>
<td>1000</td>
<td>当Kafka主题为空时会触发的初始和增量等待时间。等待时间会减少对空Kafka主题的激进ping。对于摄取用例,1秒是理想的,但对于带拦截器的低延迟操作,可能需要较低的值。</td>
</tr>
<tr>
<td>maxBackoffSleep</td>
<td>5000</td>
<td>当Kafka主题为空时触发的最大等待时间。对于摄取用例,5秒是理想的,但对于带拦截器的低延迟操作,可能需要较低的值。</td>
</tr>
<tr>
<td>useFlumeEventFormat</td>
<td>false</td>
<td>默认情况下,事件作为字节直接从Kafka主题获取到事件体中。设置为true可将事件读取为Flume Avro二进制格式。与KafkaSink上的相同属性结合使用,或与Kafka Channel上的parseAsFlumeEvent属性结合使用,这将保留在生产端发送的任何Flume标头。</td>
</tr>
<tr>
<td>setTopicHeader</td>
<td>true</td>
<td>设置为true时,会将检索到的消息的主题存储到标头中,由topicHeader属性定义。</td>
</tr>
<tr>
<td>topicHeader</td>
<td>topic</td>
<td>如果设置了setTopicHeader属性,则定义用于存储接收消息的主题名称的标头的名称。 如果与Kafka Sink topicHeader属性组合,应小心以避免消息被发送回同一主题造成循环。</td>
</tr>
<tr>
<td>timestampHeader</td>
<td>–</td>
<td>如果存在,Kafka消息时间戳值将被复制到指定的Flume标头名称。</td>
</tr>
<tr>
<td>header.NAME</td>
<td>–</td>
<td>用于标识哪些标头应该从Kafka消息添加为Flume标头。NAME的值应与Flume标头名称匹配,值应为要用作Kafka标头名称的标头的名称。</td>
</tr>
<tr>
<td>kafka.consumer.security.protocol</td>
<td>PLAINTEXT</td>
<td>如果使用某种安全级别写入Kafka,请设置为SASL_PLAINTEXT、SASL_SSL或SSL。有关安全设置的其他信息,请参见下文。</td>
</tr>
<tr>
<td><em>更多消费者安全属性</em></td>
<td></td>
<td>如果使用SASL_PLAINTEXT、SASL_SSL或SSL,请参考 <a href="[https://kafka.apache.org/documentation.html#security](https://kafka.apache.org/documentation.html#security">Kafka security</a>) 以获取在消费者上需要设置的其他属性。</td>
</tr>
<tr>
<td>其他Kafka消费者属性</td>
<td>–</td>
<td>这些属性用于配置Kafka消费者。支持的任何消费者属性 都可以使用。唯一的要求是使用前缀 kafka.consumer 为属性名称添加前缀。 例如:kafka.consumer.auto.offset.reset</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意： Kafka Source 覆盖两个 Kafka Consumer 参数：auto.commit.enable 由源设置为“false”，并且每个批次都会提交。 Kafka源保证至少一次消息检索策略。 源启动时可能会出现重复项。 Kafka Source 还提供了 key.deserializer(org.apache.kafka.common.serialization.StringSerializer) 和 value.deserializer(org.apache.kafka.common.serialization.ByteArraySerializer) 的默认值。 不建议修改这些参数。</p>
</blockquote>
<p>已弃用的属性</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Property Name</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>topic</td>
<td>–</td>
<td>使用 kafka.topics</td>
</tr>
<tr>
<td>groupId</td>
<td>flume</td>
<td>使用 kafka.consumer.group.id</td>
</tr>
<tr>
<td>zookeeperConnect</td>
<td>–</td>
<td>自 0.9.x 起，Kafka 消费者客户端不再支持。 使用kafka.bootstrap.servers与Kafka集群建立连接</td>
</tr>
<tr>
<td>migrateZookeeperOffsets</td>
<td>true</td>
<td>当没有找到Kafka存储的偏移量时，在Zookeeper中查找偏移量并将其提交给Kafka。 为了支持从旧版本 Flume 无缝迁移 Kafka 客户端，这应该是正确的。 迁移后，可以将其设置为 false，但通常不需要这样做。 如果没有找到 Zookeeper 偏移量，Kafka 配置 kafka.consumer.auto.offset.reset 定义如何处理偏移量。 有关详细信息，请查看 <a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation.html#consumerconfigs">Kafka 文档</a><br>Dāng méiyǒu zhǎodào Kafka cúnchú de piān yí liàng shí, zài Zookeeper zhōng cházhǎo pi</td>
</tr>
</tbody>
</table>
</div>
<p>通过逗号分隔的主题列表进行主题订阅的示例<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">tier1.sources.source1.type</span> = <span class="hljs-string">org.apache.flume.source.kafka.KafkaSource</span><br><span class="hljs-meta">tier1.sources.source1.channels</span> = <span class="hljs-string">channel1</span><br><span class="hljs-meta">tier1.sources.source1.batchSize</span> = <span class="hljs-string">5000</span><br><span class="hljs-meta">tier1.sources.source1.batchDurationMillis</span> = <span class="hljs-string">2000</span><br><span class="hljs-meta">tier1.sources.source1.kafka.bootstrap.servers</span> = <span class="hljs-string">localhost:9092</span><br><span class="hljs-meta">tier1.sources.source1.kafka.topics</span> = <span class="hljs-string">test1, test2</span><br><span class="hljs-meta">tier1.sources.source1.kafka.consumer.group.id</span> = <span class="hljs-string">custom.g.id</span><br></code></pre></td></tr></table></figure></p>
<p>通过正则表达式订阅主题的示例</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">tier1.sources.source1.type</span> = <span class="hljs-string">org.apache.flume.source.kafka.KafkaSource</span><br><span class="hljs-meta">tier1.sources.source1.channels</span> = <span class="hljs-string">channel1</span><br><span class="hljs-meta">tier1.sources.source1.kafka.bootstrap.servers</span> = <span class="hljs-string">localhost:9092</span><br><span class="hljs-meta">tier1.sources.source1.kafka.topics.regex</span> = <span class="hljs-string">^topic[0-9]$</span><br><span class="hljs-comment"># the default kafka.consumer.group.id=flume is used</span><br></code></pre></td></tr></table></figure>
<p><strong>Security and Kafka Source:</strong></p>
<p>Flume 和 Kafka 之间的通信通道支持安全身份验证和数据加密。 对于安全身份验证，可以从 Kafka 版本 0.9.0 开始使用 SASL/GSSAPI (Kerberos V5) 或 SSL（即使参数名为 SSL，但实际协议是 TLS 实现）。</p>
<p>目前,数据加密仅由SSL/TLS提供。<br>将kafka.consumer.security.protocol设置为以下任何值意味着:</p>
<ul>
<li><strong>SASL_PLAINTEXT</strong> - Kerberos或明文认证,没有数据加密</li>
<li><strong>SASL_SSL</strong> - Kerberos或明文认证,数据加密</li>
<li><strong>SSL</strong> - 基于TLS的加密,可选认证。</li>
</ul>
<blockquote>
<p><strong>警告 启用 SSL 时，性能会下降，其幅度取决于 CPU 类型和 JVM 实现。 参考：Kafka安全概述和跟踪此问题的jira：<a target="_blank" rel="noopener" href="https://issues.apache.org/jira/browse/KAFKA-2561">KAFKA-2561</a></strong></p>
</blockquote>
<p><strong>TLS and Kafka Source:</strong></p>
<p>请阅读配置 <a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/#security_configclients">Kafka 客户端 SSL 中描述的步骤</a>，了解用于微调的其他配置设置，例如以下任何一项：安全提供程序、密码套件、启用的协议、信任库或密钥库类型。</p>
<p>服务器端身份验证和数据加密的示例配置。<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">a1.sources.source1.type</span> = <span class="hljs-string">org.apache.flume.source.kafka.KafkaSource</span><br><span class="hljs-meta">a1.sources.source1.kafka.bootstrap.servers</span> = <span class="hljs-string">kafka-1:9093,kafka-2:9093,kafka-3:9093</span><br><span class="hljs-meta">a1.sources.source1.kafka.topics</span> = <span class="hljs-string">mytopic</span><br><span class="hljs-meta">a1.sources.source1.kafka.consumer.group.id</span> = <span class="hljs-string">flume-consumer</span><br><span class="hljs-meta">a1.sources.source1.kafka.consumer.security.protocol</span> = <span class="hljs-string">SSL</span><br><span class="hljs-comment"># optional, the global truststore can be used alternatively</span><br><span class="hljs-meta">a1.sources.source1.kafka.consumer.ssl.truststore.location</span>=<span class="hljs-string">/path/to/truststore.jks</span><br><span class="hljs-meta">a1.sources.source1.kafka.consumer.ssl.truststore.password</span>=<span class="hljs-string">&lt;password to access the truststore&gt;</span><br></code></pre></td></tr></table></figure></p>
<p>此处指定信任库是可选的，可以使用全局信任库。 有关全局 SSL 设置的更多详细信息，请参阅 SSL/TLS 支持部分。</p>
<p>注意：默认情况下，未定义属性 ssl.endpoint.identification.algorithm，因此不执行主机名验证。 为了启用主机名验证，请设置以下属性<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">a1.sources.source1.kafka.consumer.ssl.endpoint.identification.algorithm</span>=<span class="hljs-string">HTTPS</span><br></code></pre></td></tr></table></figure></p>
<p>启用后，客户端将根据以下两个字段之一验证服务器的完全限定域名 (FQDN)：</p>
<ul>
<li>通用名称（中文） <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6125#section-2.3">https://tools.ietf.org/html/rfc6125#section-2.3</a></li>
<li>主题备用名称 (SAN) <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5280#section-4.2.1.6">https://tools.ietf.org/html/rfc5280#section-4.2.1.6</a><br>如果还需要客户端身份验证，则还需要将以下内容添加到 Flume 代理配置中，或者可以使用全局 SSL 设置（请参阅 SSL/TLS 支持部分 [[flume User Guide(1.11)#^cf1b41|ssl/tls]]）。 每个 Flume 代理都必须拥有其客户端证书，该证书必须受到 Kafka 代理的单独信任或通过其签名链信任。 常见的示例是由单个根 CA 签署每个客户端证书，而该根 CA 又受到 Kafka 代理的信任。</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># optional, the global keystore can be used alternatively</span><br><span class="hljs-meta">a1.sources.source1.kafka.consumer.ssl.keystore.location</span>=<span class="hljs-string">/path/to/client.keystore.jks</span><br><span class="hljs-meta">a1.sources.source1.kafka.consumer.ssl.keystore.password</span>=<span class="hljs-string">&lt;password to access the keystore&gt;</span><br></code></pre></td></tr></table></figure>
<p>如果密钥库和密钥使用不同的密码保护，则 ssl.key.password 属性将为两个消费者密钥库提供所需的附加秘密：<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">a1.sources.source1.kafka.consumer.ssl.key.password</span>=<span class="hljs-string">&lt;password to access the key&gt;</span><br></code></pre></td></tr></table></figure></p>
<p><strong>Kerberos and Kafka Source:</strong></p>
<p>要将 Kafka Source 与受 Kerberos 保护的 Kafka 集群一起使用，请为消费者设置上面提到的 Consumer.security.protocol 属性。 与 Kafka 代理一起使用的 Kerberos 密钥表和主体在 JAAS 文件的“KafkaClient”部分中指定。 “客户端”部分描述了 Zookeeper 连接（如果需要）。 有关 JAAS 文件内容的信息，请参阅 <a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation.html#security_sasl_clientconfig">Kafka 文档</a>。 该 JAAS 文件的位置以及可选的系统范围 kerberos 配置可以通过 Flume-env.sh 中的 JAVA_OPTS 指定：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">JAVA_OPTS=&quot;$JAVA_OPTS -Djava.security.krb5.conf=/path/to/krb5.conf&quot;<br>JAVA_OPTS=&quot;$JAVA_OPTS -Djava.security.auth.login.config=/path/to/flume_jaas.conf&quot;<br></code></pre></td></tr></table></figure></p>
<p>使用 SASL_PLAINTEXT 的安全配置示例：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">a1.sources.source1.type</span> = <span class="hljs-string">org.apache.flume.source.kafka.KafkaSource</span><br><span class="hljs-meta">a1.sources.source1.kafka.bootstrap.servers</span> = <span class="hljs-string">kafka-1:9093,kafka-2:9093,kafka-3:9093</span><br><span class="hljs-meta">a1.sources.source1.kafka.topics</span> = <span class="hljs-string">mytopic</span><br><span class="hljs-meta">a1.sources.source1.kafka.consumer.group.id</span> = <span class="hljs-string">flume-consumer</span><br><span class="hljs-meta">a1.sources.source1.kafka.consumer.security.protocol</span> = <span class="hljs-string">SASL_PLAINTEXT</span><br><span class="hljs-meta">a1.sources.source1.kafka.consumer.sasl.mechanism</span> = <span class="hljs-string">GSSAPI</span><br><span class="hljs-meta">a1.sources.source1.kafka.consumer.sasl.kerberos.service.name</span> = <span class="hljs-string">kafka</span><br></code></pre></td></tr></table></figure>
<p>使用 SASL_SSL 的安全配置示例：<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">a1.sources.source1.type</span> = <span class="hljs-string">org.apache.flume.source.kafka.KafkaSource</span><br><span class="hljs-meta">a1.sources.source1.kafka.bootstrap.servers</span> = <span class="hljs-string">kafka-1:9093,kafka-2:9093,kafka-3:9093</span><br><span class="hljs-meta">a1.sources.source1.kafka.topics</span> = <span class="hljs-string">mytopic</span><br><span class="hljs-meta">a1.sources.source1.kafka.consumer.group.id</span> = <span class="hljs-string">flume-consumer</span><br><span class="hljs-meta">a1.sources.source1.kafka.consumer.security.protocol</span> = <span class="hljs-string">SASL_SSL</span><br><span class="hljs-meta">a1.sources.source1.kafka.consumer.sasl.mechanism</span> = <span class="hljs-string">GSSAPI</span><br><span class="hljs-meta">a1.sources.source1.kafka.consumer.sasl.kerberos.service.name</span> = <span class="hljs-string">kafka</span><br><span class="hljs-comment"># optional, the global truststore can be used alternatively</span><br><span class="hljs-meta">a1.sources.source1.kafka.consumer.ssl.truststore.location</span>=<span class="hljs-string">/path/to/truststore.jks</span><br><span class="hljs-meta">a1.sources.source1.kafka.consumer.ssl.truststore.password</span>=<span class="hljs-string">&lt;password to access the truststore&gt;</span><br></code></pre></td></tr></table></figure></p>
<p>示例 JAAS 文件。 有关其内容的参考，请参阅 <a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/#security_sasl_clientconfig">SASL 配置的 Kafka 文档</a>中所需身份验证机制 (GSSAPI/PLAIN) 的客户端配置部分。 由于Kafka Source也可能连接到Zookeeper进行偏移迁移，因此本示例中还添加了“Client”部分。 除非您需要偏移迁移，或者您需要此部分用于其他安全组件，否则不需要此部分。 另请确保 Flume 进程的操作系统用户具有 jaas 和 keytab 文件的读取权限。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Client &#123;<br>  com.sun.security.auth.module.Krb5LoginModule required<br>  <span class="hljs-attribute">useKeyTab</span>=<span class="hljs-literal">true</span><br>  <span class="hljs-attribute">storeKey</span>=<span class="hljs-literal">true</span><br>  <span class="hljs-attribute">keyTab</span>=<span class="hljs-string">&quot;/path/to/keytabs/flume.keytab&quot;</span><br>  <span class="hljs-attribute">principal</span>=<span class="hljs-string">&quot;flume/flumehost1.example.com@YOURKERBEROSREALM&quot;</span>;<br>&#125;;<br><br>KafkaClient &#123;<br>  com.sun.security.auth.module.Krb5LoginModule required<br>  <span class="hljs-attribute">useKeyTab</span>=<span class="hljs-literal">true</span><br>  <span class="hljs-attribute">storeKey</span>=<span class="hljs-literal">true</span><br>  <span class="hljs-attribute">keyTab</span>=<span class="hljs-string">&quot;/path/to/keytabs/flume.keytab&quot;</span><br>  <span class="hljs-attribute">principal</span>=<span class="hljs-string">&quot;flume/flumehost1.example.com@YOURKERBEROSREALM&quot;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="NetCat-TCP-Source"><a href="#NetCat-TCP-Source" class="headerlink" title="NetCat TCP Source"></a>NetCat TCP Source</h4><p>类似 netcat 的源，监听给定端口并将每一行文本转换为一个事件。 其作用类似于<br><code>nc -k -l [host] [port]</code>。<br>换句话说，它打开指定的端口并监听数据。 期望提供的数据是换行分隔的文本。 每行文本都会转化为 Flume 事件并通过连接的通道发送。<br>必需的属性以粗体显示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性名称</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>channels</strong></td>
<td>–</td>
<td></td>
</tr>
<tr>
<td><strong>type</strong></td>
<td>–</td>
<td>组件类型名称,需要为 netcat</td>
</tr>
<tr>
<td><strong>bind</strong></td>
<td>–</td>
<td>要绑定的主机名或 IP 地址</td>
</tr>
<tr>
<td><strong>port</strong></td>
<td>–</td>
<td>要绑定的端口号</td>
</tr>
<tr>
<td>max-line-length</td>
<td>512</td>
<td>每条事件体的最大行长度(以字节为单位)</td>
</tr>
<tr>
<td>ack-every-event</td>
<td>true</td>
<td>对收到的每条事件响应“OK”</td>
</tr>
<tr>
<td>selector.type</td>
<td>replicating</td>
<td>replicating 或 multiplexing</td>
</tr>
<tr>
<td>selector.*</td>
<td></td>
<td>依赖于 selector.type 值</td>
</tr>
<tr>
<td>interceptors</td>
<td>–</td>
<td>空格分隔的拦截器列表</td>
</tr>
<tr>
<td>interceptors.*</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>名为 a1 的代理示例：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">a1.sources</span> = <span class="hljs-string">r1</span><br><span class="hljs-meta">a1.channels</span> = <span class="hljs-string">c1</span><br><span class="hljs-meta">a1.sources.r1.type</span> = <span class="hljs-string">netcat</span><br><span class="hljs-meta">a1.sources.r1.bind</span> = <span class="hljs-string">0.0.0.0</span><br><span class="hljs-meta">a1.sources.r1.port</span> = <span class="hljs-string">6666</span><br><span class="hljs-meta">a1.sources.r1.channels</span> = <span class="hljs-string">c1</span><br></code></pre></td></tr></table></figure>
<h4 id="NetCat-UDP-Source"><a href="#NetCat-UDP-Source" class="headerlink" title="NetCat UDP Source"></a>NetCat UDP Source</h4><p>根据原始 Netcat (TCP) 源，该源侦听给定端口并将每行文本转换为事件并通过连接的通道发送。 行为就像 <code>nc -u -k -l [host] [port]</code><br>必需的属性以粗体显示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性名称</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>channels</strong></td>
<td>–</td>
<td></td>
</tr>
<tr>
<td><strong>type</strong></td>
<td>–</td>
<td>组件类型名称,需要为 <code>netcatudp</code></td>
</tr>
<tr>
<td><strong>bind</strong></td>
<td>–</td>
<td>要绑定的主机名或 IP 地址</td>
</tr>
<tr>
<td><strong>port</strong></td>
<td>–</td>
<td>要绑定的端口号</td>
</tr>
<tr>
<td>remoteAddressHeader</td>
<td>–</td>
<td></td>
</tr>
<tr>
<td>selector.type</td>
<td>replicating</td>
<td>replicating 或 multiplexing</td>
</tr>
<tr>
<td>selector.*</td>
<td></td>
<td>依赖于 selector.type 值</td>
</tr>
<tr>
<td>interceptors</td>
<td>–</td>
<td>空格分隔的拦截器列表</td>
</tr>
<tr>
<td>interceptors.*</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>名为 a1 的代理示例：<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">a1.sources</span> = <span class="hljs-string">r1</span><br><span class="hljs-meta">a1.channels</span> = <span class="hljs-string">c1</span><br><span class="hljs-meta">a1.sources.r1.type</span> = <span class="hljs-string">netcatudp</span><br><span class="hljs-meta">a1.sources.r1.bind</span> = <span class="hljs-string">0.0.0.0</span><br><span class="hljs-meta">a1.sources.r1.port</span> = <span class="hljs-string">6666</span><br><span class="hljs-meta">a1.sources.r1.channels</span> = <span class="hljs-string">c1</span><br></code></pre></td></tr></table></figure></p>
<h4 id="Sequence-Generator-Source"><a href="#Sequence-Generator-Source" class="headerlink" title="Sequence Generator Source"></a>Sequence Generator Source</h4><p>一个简单的序列生成器，它使用从 0 开始、以 1 递增并在totalEvents 处停止的计数器连续生成事件。 当无法将事件发送到通道时重试。 主要用于测试。 在重试期间，它会保持重试消息的正文与之前相同，以便在目的地进行重复数据删除之后，唯一事件的数量预计等于指定的totalEvents。 必需的属性以粗体显示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性名称</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>channels</strong></td>
<td>–</td>
<td></td>
</tr>
<tr>
<td><strong>type</strong></td>
<td>–</td>
<td>组件类型名称,需要为 seq</td>
</tr>
<tr>
<td>selector.type</td>
<td></td>
<td>replicating 或 multiplexing</td>
</tr>
<tr>
<td>selector.*</td>
<td>replicating</td>
<td>取决于 selector.type 值</td>
</tr>
<tr>
<td>interceptors</td>
<td>–</td>
<td>空格分隔的拦截器列表</td>
</tr>
<tr>
<td>interceptors.*</td>
<td></td>
<td></td>
</tr>
<tr>
<td>batchSize</td>
<td>1</td>
<td>每次请求循环尝试处理的事件数。</td>
</tr>
<tr>
<td>totalEvents</td>
<td>Long.MAX_VALUE</td>
<td>源发送的唯一事件数。</td>
</tr>
</tbody>
</table>
</div>
<p>名为 a1 的代理示例：<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">a1.sources</span> = <span class="hljs-string">r1</span><br><span class="hljs-meta">a1.channels</span> = <span class="hljs-string">c1</span><br><span class="hljs-meta">a1.sources.r1.type</span> = <span class="hljs-string">seq</span><br><span class="hljs-meta">a1.sources.r1.channels</span> = <span class="hljs-string">c1</span><br></code></pre></td></tr></table></figure></p>
<h4 id="Syslog-Sources"><a href="#Syslog-Sources" class="headerlink" title="Syslog Sources"></a>Syslog Sources</h4><p>读取系统日志数据并生成 Flume 事件。 UDP 源将整个消息视为单个事件。 TCP 源为每个由换行符 (‘n’) 分隔的字符串创建一个新事件。<br>必需的属性以粗体显示。</p>
<h5 id="Syslog-TCP-Source"><a href="#Syslog-TCP-Source" class="headerlink" title="Syslog TCP Source"></a>Syslog TCP Source</h5><p>原始的、经过验证的 syslog TCP 源。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性名称</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>channels</strong></td>
<td>–</td>
<td></td>
</tr>
<tr>
<td><strong>type</strong></td>
<td>–</td>
<td>组件类型名称,需要为 syslogtcp</td>
</tr>
<tr>
<td><strong>host</strong></td>
<td>–</td>
<td>要绑定的主机名或 IP 地址</td>
</tr>
<tr>
<td><strong>port</strong></td>
<td>–</td>
<td>要绑定的端口号</td>
</tr>
<tr>
<td>eventSize</td>
<td>2500</td>
<td>单个事件行的最大大小(以字节为单位)</td>
</tr>
<tr>
<td>keepFields</td>
<td>none</td>
<td>将此设置为“all”将在事件正文中保留优先级、时间戳和主机名。也允许以空格分隔的字段列表。当前,可以包含以下字段:priority、version、timestamp、hostname。值“true”和“false”已弃用,改用“all”和“none”。</td>
</tr>
<tr>
<td>clientIPHeader</td>
<td>–</td>
<td>如果指定,客户端的 IP 地址将使用此处指定的标头名称存储在每个事件的标头中。这允许拦截器和通道选择器根据客户端的 IP 地址自定义路由逻辑。不要在这里使用标准的 Syslog 标头名称(如 <em>host</em>),因为事件标头在那种情况下会被覆盖。</td>
</tr>
<tr>
<td>clientHostnameHeader</td>
<td>–</td>
<td>如果指定,客户端的主机名将使用此处指定的标头名称存储在每个事件的标头中。这允许拦截器和通道选择器根据客户端的主机名自定义路由逻辑。检索主机名可能涉及名称服务反向查找,这可能会影响性能。不要在这里使用标准的 Syslog 标头名称(如 <em>host</em>),因为事件标头在那种情况下会被覆盖。</td>
</tr>
<tr>
<td>selector.type</td>
<td></td>
<td>replicating 或 multiplexing</td>
</tr>
<tr>
<td>selector.*</td>
<td>replicating</td>
<td>取决于 selector.type 值</td>
</tr>
<tr>
<td>interceptors</td>
<td>–</td>
<td>空格分隔的拦截器列表</td>
</tr>
<tr>
<td>interceptors.*</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ssl</td>
<td>false</td>
<td>将此设置为 true 以启用 SSL 加密。如果启用 SSL,还必须通过组件级参数(参见下文)或全局 SSL 参数(参见 <a target="_blank" rel="noopener" href="https://flume.apache.org/releases/content/1.11.0/FlumeUserGuide.html#ssl-tls-support">SSL/TLS support</a>) 部分)指定“keystore”和“keystore-password”。</td>
</tr>
<tr>
<td>keystore</td>
<td>–</td>
<td>这是 Java 密钥库文件的路径。如果在这里未指定,则将使用全局密钥库(如果已定义,否则将产生配置错误)。</td>
</tr>
<tr>
<td>keystore-password</td>
<td>–</td>
<td>Java 密钥库的密码。如果在此未指定,则将使用全局密钥库密码(如果已定义,否则会产生配置错误)。</td>
</tr>
<tr>
<td>keystore-type</td>
<td>JKS</td>
<td>Java 密钥库的类型。可以是 “JKS” 或 “PKCS12”。如果在此处未指定,则将使用全局密钥库类型(如果已定义,否则默认为 JKS)。</td>
</tr>
<tr>
<td>exclude-protocols</td>
<td>SSLv3</td>
<td>要排除的 SSL/TLS 协议的以空格分隔的列表。除了指定的协议之外,还将始终排除 SSLv3。</td>
</tr>
<tr>
<td>include-protocols</td>
<td>–</td>
<td>要包括的 SSL/TLS 协议的以空格分隔的列表。启用的协议将是不含排除协议的包含协议。如果 include-protocols 为空,它将包含每个支持的协议。</td>
</tr>
<tr>
<td>exclude-cipher-suites</td>
<td>–</td>
<td>要排除的密码套件的以空格分隔的列表。</td>
</tr>
<tr>
<td>include-cipher-suites</td>
<td>–</td>
<td>要包含的密码组合的以空格分隔的列表。启用的密码组合将是不含排除的密码组合的包含密码组合。如果 include-cipher-suites 为空,它将包含每个支持的密码组合。</td>
</tr>
</tbody>
</table>
</div>
<p>例如，名为 a1 的代理的 syslog TCP source：<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">a1.sources</span> = <span class="hljs-string">r1</span><br><span class="hljs-meta">a1.channels</span> = <span class="hljs-string">c1</span><br><span class="hljs-meta">a1.sources.r1.type</span> = <span class="hljs-string">syslogtcp</span><br><span class="hljs-meta">a1.sources.r1.port</span> = <span class="hljs-string">5140</span><br><span class="hljs-meta">a1.sources.r1.host</span> = <span class="hljs-string">localhost</span><br><span class="hljs-meta">a1.sources.r1.channels</span> = <span class="hljs-string">c1</span><br></code></pre></td></tr></table></figure></p>
<h5 id="Multiport-Syslog-TCP-Source"><a href="#Multiport-Syslog-TCP-Source" class="headerlink" title="Multiport Syslog TCP Source"></a>Multiport Syslog TCP Source</h5><p>这是 Syslog TCP 源的更新、更快、支持多端口的版本。 请注意，端口配置设置已替换端口。 多端口功能意味着它可以高效地同时侦听多个端口。 该源使用 Apache Mina 库来执行此操作。 提供对 RFC-3164 和许多常见 RFC-5424 格式消息的支持。 还提供配置每个端口使用的字符集的功能。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性名称</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>channels</strong></td>
<td>–</td>
<td></td>
</tr>
<tr>
<td><strong>type</strong></td>
<td>–</td>
<td>组件类型名称,需要为 multiport_syslogtcp</td>
</tr>
<tr>
<td><strong>host</strong></td>
<td>–</td>
<td>要绑定的主机名或 IP 地址</td>
</tr>
<tr>
<td><strong>ports</strong></td>
<td>–</td>
<td>要绑定的一个或多个端口的空格分隔列表</td>
</tr>
<tr>
<td>eventSize</td>
<td>2500</td>
<td>单个事件行的最大大小(以字节为单位)</td>
</tr>
<tr>
<td>keepFields</td>
<td>none</td>
<td>将此设置为“all”将在事件正文中保留优先级、时间戳和主机名。也允许以空格分隔的字段列表。 当前可以包含以下字段:priority、version、timestamp、hostname。值“true”和“false”已弃用,改用“all”和“none”。</td>
</tr>
<tr>
<td>portHeader</td>
<td>–</td>
<td>如果指定,端口号将使用此处指定的标头名称存储在每个事件的标头中。这允许拦截器和通道选择器根据传入端口自定义路由逻辑。</td>
</tr>
<tr>
<td>clientIPHeader</td>
<td>–</td>
<td>如果指定,客户端的IP地址将使用此处指定的标头名称存储在每个事件的标头中。这允许拦截器和通道选择器根据客户端的IP地址自定义路由逻辑。不要在这里使用标准的Syslog标头名称(如 _host_) 因为事件标头在那种情况下会被覆盖。</td>
</tr>
<tr>
<td>clientHostnameHeader</td>
<td>–</td>
<td>如果指定,客户端的主机名将使用此处指定的标头名称存储在每个事件的标头中。这允许拦截器和通道选择器根据客户端的主机名自定义路由逻辑。检索主机名可能涉及名称服务反向查找,这可能会影响性能。不要在这里使用标准的Syslog标头名称(如 _host_)因为事件标头在那种情况下会被覆盖。</td>
</tr>
<tr>
<td>charset.default</td>
<td>UTF-8</td>
<td>解析syslog事件为字符串时使用的默认字符集。</td>
</tr>
<tr>
<td>charset.port.\<port></td>
<td>–</td>
<td>可以对每个端口配置字符集。</td>
</tr>
<tr>
<td>batchSize</td>
<td>100</td>
<td>每次请求循环尝试处理的最大事件数。使用默认值通常就好。</td>
</tr>
<tr>
<td>readBufferSize</td>
<td>1024</td>
<td>内部Mina读取缓冲区的大小。提供性能优化。使用默认值通常就好。</td>
</tr>
<tr>
<td>numProcessors</td>
<td>(auto-detected)</td>
<td>用于处理消息的系统上可用的处理器数。默认情况下,使用Java运行时API自动检测CPU数。Mina将为每个检测到的CPU生成2个请求处理线程,这通常是合理的。</td>
</tr>
<tr>
<td>selector.type</td>
<td>replicating</td>
<td>replicating、multiplexing或custom</td>
</tr>
<tr>
<td>selector.*</td>
<td>–</td>
<td>依赖于selector.type的值</td>
</tr>
<tr>
<td>interceptors</td>
<td>–</td>
<td>空格分隔的拦截器列表。</td>
</tr>
<tr>
<td>interceptors.*</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ssl</td>
<td>false</td>
<td>将此设置为true可启用SSL加密。 如果启用SSL,还必须通过组件级参数(参见下文)或全局SSL参数(请参阅<a target="_blank" rel="noopener" href="https://flume.apache.org/releases/content/1.11.0/FlumeUserGuide.html#ssl-tls-support">SSL/TLS支持</a>部分)指定“keystore”和“keystore-password”。</td>
</tr>
<tr>
<td>keystore</td>
<td>–</td>
<td>这是Java密钥库文件的路径。如果在这里未指定,则将使用全局密钥库(如果已定义,否则将产生配置错误)。</td>
</tr>
<tr>
<td>keystore-password</td>
<td>–</td>
<td>Java密钥库的密码。如果在此未指定,则将使用全局密钥库密码(如果已定义,否则会产生配置错误)。</td>
</tr>
<tr>
<td>keystore-type</td>
<td>JKS</td>
<td>Java密钥库的类型。可以是“JKS”或“PKCS12”。如果在此处未指定,则将使用全局密钥库类型(如果已定义,否则默认为JKS)。</td>
</tr>
<tr>
<td>exclude-protocols</td>
<td>SSLv3</td>
<td>要排除的SSL/TLS协议的以空格分隔的列表。除了指定的协议之外,还将始终排除SSLv3。</td>
</tr>
<tr>
<td>include-protocols</td>
<td>–</td>
<td>要包含的SSL/TLS协议的以空格分隔的列表。启用的协议将是不含排除协议的包含协议。如果include-protocols为空,它将包含每个支持的协议。</td>
</tr>
<tr>
<td>exclude-cipher-suites</td>
<td>–</td>
<td>要排除的密码套件的以空格分隔的列表。</td>
</tr>
<tr>
<td>include-cipher-suites</td>
<td>–</td>
<td>要包含的密码组合的以空格分隔的列表。启用的密码组合将是不含排除的密码组合的包含密码组合。如果include-cipher-suites为空,它将包含每个支持的密码组合。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Syslog-UDP-Source"><a href="#Syslog-UDP-Source" class="headerlink" title="Syslog UDP Source"></a>Syslog UDP Source</h5><div class="table-container">
<table>
<thead>
<tr>
<th>属性名称</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>channels</strong></td>
<td>–</td>
<td></td>
</tr>
<tr>
<td><strong>type</strong></td>
<td>–</td>
<td>组件类型名称,需要为 syslogudp</td>
</tr>
<tr>
<td><strong>host</strong></td>
<td>–</td>
<td>要绑定的主机名或 IP 地址</td>
</tr>
<tr>
<td><strong>port</strong></td>
<td>–</td>
<td>要绑定的端口号</td>
</tr>
<tr>
<td>keepFields</td>
<td>false</td>
<td>将此设置为 true 将在事件正文中保留优先级、时间戳和主机名。</td>
</tr>
<tr>
<td>clientIPHeader</td>
<td>–</td>
<td>如果指定,客户端的 IP 地址将使用此处指定的标头名称存储在每个事件的标头中。这允许拦截器和通道选择器根据客户端的 IP 地址自定义路由逻辑。不要在这里使用标准的 Syslog 标头名称(如 _host_),因为事件标头在那种情况下会被覆盖。</td>
</tr>
<tr>
<td>clientHostnameHeader</td>
<td>–</td>
<td>如果指定,客户端的主机名将使用此处指定的标头名称存储在每个事件的标头中。这允许拦截器和通道选择器根据客户端的主机名自定义路由逻辑。检索主机名可能涉及名称服务反向查找,这可能会影响性能。不要在这里使用标准的 Syslog 标头名称(如 _host_),因为事件标头在那种情况下会被覆盖。</td>
</tr>
<tr>
<td>selector.type</td>
<td></td>
<td>replicating 或 multiplexing</td>
</tr>
<tr>
<td>selector.*</td>
<td>replicating</td>
<td>取决于 selector.type 值</td>
</tr>
<tr>
<td>interceptors</td>
<td>–</td>
<td>空格分隔的拦截器列表</td>
</tr>
<tr>
<td>interceptors.*</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>例如，名为 a1 的代理的 syslog UDP source：<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">a1.sources</span> = <span class="hljs-string">r1</span><br><span class="hljs-meta">a1.channels</span> = <span class="hljs-string">c1</span><br><span class="hljs-meta">a1.sources.r1.type</span> = <span class="hljs-string">syslogudp</span><br><span class="hljs-meta">a1.sources.r1.port</span> = <span class="hljs-string">5140</span><br><span class="hljs-meta">a1.sources.r1.host</span> = <span class="hljs-string">localhost</span><br><span class="hljs-meta">a1.sources.r1.channels</span> = <span class="hljs-string">c1</span><br></code></pre></td></tr></table></figure></p>
<h4 id="HTTP-Source"><a href="#HTTP-Source" class="headerlink" title="HTTP Source"></a>HTTP Source</h4><p>通过 HTTP POST 和 GET 接受 Flume 事件的源。 GET 只能用于实验。 HTTP 请求通过可插入“handler”转换为 Flume 事件，该处理程序必须实现 HTTPSourceHandler 接口。 该处理程序接受 HttpServletRequest 并返回 Flume 事件列表。 从一个 Http 请求处理的所有事件都会在一个事务中提交到通道，从而提高文件通道等通道的效率。 如果处理程序引发异常，该源将返回 HTTP 状态 400。如果通道已满，或者源无法将事件附加到通道，则源将返回 HTTP 503 - 暂时不可用状态。</p>
<p>在一个 post 请求中发送的所有事件都被视为一批并在一笔事务中插入到通道中。</p>
<p>该源基于 Jetty 9.4，并提供设置其他 Jetty 特定参数的能力，这些参数将直接传递到 Jetty 组件。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/flume/">flume</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/flume%E6%96%87%E6%A1%A3/">flume文档</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/07/10/%E5%A4%A7%E6%95%B0%E6%8D%AE/hive2.1.1%20%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB%E9%AB%98%E7%89%88%E6%9C%AChive-orc%E6%95%B0%E6%8D%AE/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">hive2.1.1 无法识别高版本hive-orc数据</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/05/15/flume/flume%20User%20Guide(1.11)/">
                        <span class="hidden-mobile">flume-User-Guide(1.11)(翻译中)</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
