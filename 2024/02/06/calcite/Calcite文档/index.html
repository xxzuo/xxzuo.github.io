

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="xxzuo">
  <meta name="keywords" content="">
  
  <title>Calcite文档 - Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"xxzuo.github.io","root":"/","version":"1.8.9","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>xxzuo</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Calcite文档">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      xxzuo
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2024-02-06 16:15" pubdate>
        2024年2月6日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      56
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Calcite文档</h1>
            
            <div class="markdown-body">
              <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Apache Calcite是一个动态数据管理框架。</p>
<p>它包含了许多组成典型数据库管理系统的部分，但省略了一些关键功能：数据存储、处理数据的算法和存储元数据的存储库。</p>
<p>Calcite有意不参与数据存储和处理业务。正如我们将看到的，这使它成为在应用程序与一个或多个数据存储位置和数据处理引擎之间进行中介的绝佳选择。它也是构建数据库的完美基础：只需添加数据即可。</p>
<p>为了进行说明，让我们创建一个Calcite的空实例，然后将其指向一些数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HrSchema</span> </span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Employee[] emps = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Department[] depts = <span class="hljs-number">0</span>;  <br>&#125;  <br>Class.forName(<span class="hljs-string">&quot;org.apache.calcite.jdbc.Driver&quot;</span>);  <br>Properties info = <span class="hljs-keyword">new</span> Properties(); info.setProperty(<span class="hljs-string">&quot;lex&quot;</span>,<span class="hljs-string">&quot;JAVA&quot;</span>);  <br>Connection connection = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:calcite:&quot;</span>, info);  <br>CalciteConnection calciteConnection = connection.unwrap(CalciteConnection.class);  <br>SchemaPlus rootSchema = calciteConnection.getRootSchema();  <br>Schema schema = <span class="hljs-keyword">new</span> ReflectiveSchema(<span class="hljs-keyword">new</span> HrSchema()); rootSchema.add(<span class="hljs-string">&quot;hr&quot;</span>,schema);  <br>Statement statement = calciteConnection.createStatement();  <br>ResultSet resultSet = statement.executeQuery(<span class="hljs-string">&quot;select d.deptno, min(e.empid)\n&quot;</span> + <span class="hljs-string">&quot;from hr.emps as e\n&quot;</span> + <span class="hljs-string">&quot;join hr.depts as d\n&quot;</span> + <span class="hljs-string">&quot; on e.deptno = d.deptno\n&quot;</span> + <span class="hljs-string">&quot;group by d.deptno\n&quot;</span> + <span class="hljs-string">&quot;having count(*) &gt; 1&quot;</span>);  <br>  <br>print(resultSet); resultSet.close(); statement.close(); connection.close();<br></code></pre></td></tr></table></figure>
<p>数据库在哪里？没有数据库。连接完全为空，直到 <code>new ReflectiveSchema</code> 将Java对象注册为模式，并将其集合字段<code>emps</code>和<code>depts</code>注册为表。</p>
<p>Calcite不想拥有数据；它甚至没有喜欢的数据格式。此示例使用内存中的数据集，并使用 <code>linq4j</code> 库中的<code>groupBy</code>和<code>join</code>等运算符对其进行处理。但是Calcite 也可以处理其他数据格式的数据，例如JDBC。在第一个示例中，替换<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Schema schema = <span class="hljs-keyword">new</span> ReflectiveSchema(<span class="hljs-keyword">new</span> HrSchema());<br></code></pre></td></tr></table></figure></p>
<p>为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">BasicDataSource dataSource = <span class="hljs-keyword">new</span> BasicDataSource();  <br>dataSource.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost&quot;</span>);  <br>dataSource.setUsername(<span class="hljs-string">&quot;username&quot;</span>);  <br>dataSource.setPassword(<span class="hljs-string">&quot;password&quot;</span>);  <br>Schema schema = JdbcSchema.create(rootSchema, <span class="hljs-string">&quot;hr&quot;</span>, dataSource,  <br>        <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;name&quot;</span>);<br></code></pre></td></tr></table></figure></p>
<p>Calcite将在JDBC中执行相同的查询。对于应用程序来说，数据和API是相同的，但在后台实现是非常不同的。Calcite使用优化器规则将 <code>JOIN</code> 和 <code>GROUP BY</code> 操作推送到源数据库。</p>
<p>内存和JDBC只是两个熟悉的例子。Calcite可以处理任何数据源和数据格式。要添加数据源，您需要编写一个适配器，该适配器告诉Calcite应该将数据源中的哪些集合视为 <code>table</code>。</p>
<p>对于更高级的集成，您可以编写优化器规则。优化器规则允许Calcite访问新格式的数据，允许您注册新的运算符（例如更好的 <code>Join</code> 算法），也允许Calcite优化查询转换为运算符的方式。Calcite将您的规则和运算符与内置规则和运算符相结合，使用基于成本的优化模型，生成一个高效的计划。</p>
<h3 id="编写一个适配器"><a href="#编写一个适配器" class="headerlink" title="编写一个适配器"></a>编写一个适配器</h3><p><code>example/csv</code> 目录下的子项目提供了一个功能齐全、可用于应用程序的 CSV 适配器。它也足够简单，如果您正在编写自己的适配器，它可以作为一个很好的模板。</p>
<p>关于使用 CSV 适配器和编写其他适配器的信息，请参考<a target="_blank" rel="noopener" href="https://calcite.apache.org/docs/tutorial.html">教程</a></p>
<p>关于使用其他适配器以及常规使用 Calcite 的更多信息，请参考<a target="_blank" rel="noopener" href="https://calcite.apache.org/docs/howto.html">如何去做</a></p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>以下功能已完成</p>
<ul>
<li>查询解析器、验证器和优化器</li>
<li>支持读取 JSON 格式的模型</li>
<li>许多标准函数和聚合函数</li>
<li>针对 Linq4j 和 JDBC 后端的JDBC查询</li>
<li>Linq4j 前端</li>
<li>SQL功能：<code>SELECT</code>、<code>FROM</code>（包括 <code>JOIN</code> 语法）、<code>WHERE</code>、<code>GROUP BY</code>（包括<code>GROUPING SETS</code>）、聚合函数（包括<code>COUNT(DISTINCT …)</code>和 <code>FILTER</code> ）、<code>HAVING</code>、<code>ORDER BY</code>（包括<code>NULLS FIRST/LAST</code>）、集操作（<code>UNION</code>、<code>INTERSECT</code>、<code>MINUS</code>）、子查询（包括相关子查询）、窗口聚合、LIMIT(如 <a target="_blank" rel="noopener" href="https://www.postgresql.org/docs/8.4/static/sql-select.html#SQL-LIMIT">Postgres</a> 语法)——更多详细信息参考<a target="_blank" rel="noopener" href="https://calcite.apache.org/docs/reference.html">SQL参考</a></li>
<li>本地和远程JDBC驱动程序；参考 <a target="_blank" rel="noopener" href="https://calcite.apache.org/docs/avatica_overview.html">Avatica</a></li>
<li>几个<a target="_blank" rel="noopener" href="https://calcite.apache.org/docs/adapter.html">适配器</a></li>
</ul>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>这是一个循序渐进的教程，展示了如何构建和连接Calcite。它使用一个简单的适配器，使CSV文件的目录看起来像是包含表的模式。Calcite完成了剩下的工作，并提供了一个完整的SQL接口。</p>
<p><code>Calcite-example-CSV</code> 是Calcite的一个功能齐全的适配器，用于读取<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV（逗号分隔值）</a>格式的文本文件。 值得注意的是，几百行Java代码就足以提供完整的SQL查询功能。</p>
<p>CSV还可以作为构建其他数据格式适配器的模板。尽管代码行不多，但它涵盖了几个重要概念：</p>
<ul>
<li>使用SchemaFactory和schema接口的用户定义模式;</li>
<li>在 JSON 格式的模型文件中声明模式;</li>
<li>在 JSON 格式的模型文件中声明视图;</li>
<li>使用 <code>Table</code> 接口的用户自定义表;</li>
<li>确定表的记录类型;</li>
<li>表的一个简单实现，使用<code>ScannableTable</code>接口，直接枚举所有行;</li>
<li>一个更高级的实现，它实现了<code>FilterableTable</code>，并且可以根据简单的谓词过滤掉行;</li>
<li>表的高级实现，使用<code>TranslatableTable</code>，使用计划器规则转换为关系运算符;</li>
</ul>
<h3 id="下载和构建"><a href="#下载和构建" class="headerlink" title="下载和构建"></a>下载和构建</h3><p>你需要 <code>Java</code>（版本 8、9 或 10）和 <code>Git</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> https://github.com/apache/calcite.git</span> <br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> calcite/example/csv</span> <br><span class="hljs-meta">$</span><span class="bash"> ./sqlline</span><br></code></pre></td></tr></table></figure></p>
<h4 id="第一个查询"><a href="#第一个查询" class="headerlink" title="第一个查询"></a>第一个查询</h4><p>现在，让我们使用 <code>sqlline</code> 连接到Calcite，<a target="_blank" rel="noopener" href="https://github.com/julianhyde/sqlline">sqlline</a> 是该项目中包含的SQL shell。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ./sqlline</span><br><span class="hljs-meta">sqlline&gt;</span><span class="bash"> !connect jdbc:calcite:model=src/<span class="hljs-built_in">test</span>/resources/model.json admin admin</span><br></code></pre></td></tr></table></figure>
<p>（如果您运行的是Windows，则命令为<code>sqlline.bat</code>。）</p>
<p>执行元数据查询：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">sqlline&gt;</span><span class="bash"> !tables</span><br>+------------+--------------+-------------+---------------+----------+------+<br>| TABLE_CAT  | TABLE_SCHEM  | TABLE_NAME  |  TABLE_TYPE   | REMARKS  | TYPE |<br>+------------+--------------+-------------+---------------+----------+------+<br>| null       | SALES        | DEPTS       | TABLE         | null     | null |<br>| null       | SALES        | EMPS        | TABLE         | null     | null |<br>| null       | SALES        | HOBBIES     | TABLE         | null     | null |<br>| null       | metadata     | COLUMNS     | SYSTEM_TABLE  | null     | null |<br>| null       | metadata     | TABLES      | SYSTEM_TABLE  | null     | null |<br>+------------+--------------+-------------+---------------+----------+------+<br><br></code></pre></td></tr></table></figure></p>
<p>JDBC 专家们注意：<code>sqlline</code> 的 <code>!tables</code> 命令只是在背后执行了  <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/sql/DatabaseMetaData.html#getTables(java.lang.String,%20java.lang.String,%20java.lang.String,%20java.lang.String%5B%5D">DatabaseMetaData.getTables()</a>) 方法。它也提供了其他命令，可以用来查询 JDBC 元数据，例如 <code>!columns</code> 和 <code>!describe</code>。</p>
<p>正如你看见的，系统中有 5 张表： <code>EMPS</code>，<code>DEPTS</code> 和 <code>HOBBIES</code> 表在当前 <code>SALES</code> 模式中，<code>COLUMNS</code> 和 <code>TABLES</code> 表在系统 <code>metadata</code> 模式中。系统表始终存在于 Calcite 中，而其他表则由模式的具体实现提供。在这个场景下，<code>EMPS</code> 和 <code>DEPTS</code> 表是基于 <code>resources/sales</code> 目录下的 <code>EMPS.csv</code> 和 <code>DEPTS.csv</code> 文件。</p>
<p>让我们对这些表执行一些查询，来展示 Calcite 提供的 SQL 完整实现。首先，进行表扫描：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">sqlline&gt;</span><span class="bash"> SELECT * FROM emps;</span><br>+--------+--------+---------+---------+----------------+--------+-------+---+<br>| EMPNO  |  NAME  | DEPTNO  | GENDER  |      CITY      | EMPID  |  AGE  | S |<br>+--------+--------+---------+---------+----------------+--------+-------+---+<br>| 100    | Fred   | 10      |         |                | 30     | 25    | t |<br>| 110    | Eric   | 20      | M       | San Francisco  | 3      | 80    | n |<br>| 110    | John   | 40      | M       | Vancouver      | 2      | null  | f |<br>| 120    | Wilma  | 20      | F       |                | 1      | 5     | n |<br>| 130    | Alice  | 40      | F       | Vancouver      | 2      | null  | f |<br>+--------+--------+---------+---------+----------------+--------+-------+---+<br><br></code></pre></td></tr></table></figure></p>
<p>再进行关联和分组查询：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">sqlline&gt;</span><span class="bash"> SELECT d.name, COUNT(*)</span> <br>. . . .&gt; FROM emps AS e JOIN depts AS d ON e.deptno = d.deptno <br>. . . .&gt; GROUP BY d.name; <br>+------------+---------+ <br>| NAME       | EXPR$1  | <br>+------------+---------+ <br>| Sales      | 1       |<br>| Marketing  | 2       | <br>+------------+---------+<br></code></pre></td></tr></table></figure></p>
<p>最后，VALUES运算符生成一行，是测试表达式和SQL内置函数的一种方便方法<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">sqlline&gt;</span><span class="bash"> VALUES CHAR_LENGTH(<span class="hljs-string">&#x27;Hello, &#x27;</span> || <span class="hljs-string">&#x27;world!&#x27;</span>);</span><br>+---------+<br>| EXPR$0  |<br>+---------+<br>| 13      |<br>+---------+<br><br></code></pre></td></tr></table></figure></p>
<p>Calcite还有许多其他SQL功能。我们没有时间在这里报道他们。你可以再写一些查询进行实验。</p>
<h3 id="模式发现"><a href="#模式发现" class="headerlink" title="模式发现"></a>模式发现</h3><p>现在，Calcite是如何找到这些表格的？记住，核心Calcite对CSV文件一无所知。（作为一个“没有存储层的数据库”，Calcite不知道任何文件格式）。Calcite 知道这些表，完全是因为我们告诉它去执行 <code>calcite-example-csv</code> 项目中的代码。</p>
<p>发现过程包含了几个步骤。首先，我们基于模型文件中的模式工厂类定义了一个模式。然后，模式工厂创建了一个模式，并且这个模式创建一些表，每个表都知道通过扫描 CSV 文件来获取数据。最后，在 Calcite 解析完查询并生成使用这些表的执行计划后，Calcite 会在执行查询时，调用这些表来读取数据。现在让我们更详细地了解这些步骤。</p>
<p>在 JDBC 连接字符串上，我们以 JSON 格式给出了模型的路径。下面是模型的内容：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0&quot;</span>,<br>    <span class="hljs-attr">&quot;defaultSchema&quot;</span>: <span class="hljs-string">&quot;SALES&quot;</span>,<br>    <span class="hljs-attr">&quot;schemas&quot;</span>: [<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;SALES&quot;</span>,<br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;custom&quot;</span>,<br>            <span class="hljs-attr">&quot;factory&quot;</span>: <span class="hljs-string">&quot;org.apache.calcite.adapter.csv.CsvSchemaFactory&quot;</span>,<br>            <span class="hljs-attr">&quot;operand&quot;</span>: &#123;<br>                <span class="hljs-attr">&quot;directory&quot;</span>: <span class="hljs-string">&quot;sales&quot;</span><br>            &#125;<br>        &#125;<br>    ]<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>模型定义了一个名为 <code>SALES</code> 的单模式。这个模式由插件类 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/main/example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvSchemaFactory.java">org.apache.calcite.adapter.csv.CsvSchemaFactory</a>  提供支持，它是 <code>calcite-example-csv</code> 项目的一部分，并实现了 Calcite  <a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/schema/SchemaFactory.html">SchemaFactory</a>  接口。它的 <code>create</code> 方法，通过从模型文件中传入的 <code>directory</code> 参数，实例化了模式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Schema <span class="hljs-title">create</span><span class="hljs-params">(SchemaPlus parentSchema, String name,  </span></span><br><span class="hljs-function"><span class="hljs-params">                     Map&lt;String, Object&gt; operand)</span> </span>&#123;  <br>    <span class="hljs-keyword">final</span> String directory = (String) operand.get(<span class="hljs-string">&quot;directory&quot;</span>);  <br>    <span class="hljs-keyword">final</span> File base =  <br>            (File) operand.get(ModelHandler.ExtraOperand.BASE_DIRECTORY.camelName);  <br>    File directoryFile = <span class="hljs-keyword">new</span> File(directory);  <br>    <span class="hljs-keyword">if</span> (base != <span class="hljs-keyword">null</span> &amp;&amp; !directoryFile.isAbsolute()) &#123;  <br>        directoryFile = <span class="hljs-keyword">new</span> File(base, directory);  <br>    &#125;  <br>    String flavorName = (String) operand.get(<span class="hljs-string">&quot;flavor&quot;</span>);  <br>    CsvTable.Flavor flavor;  <br>    <span class="hljs-keyword">if</span> (flavorName == <span class="hljs-keyword">null</span>) &#123;  <br>        flavor = CsvTable.Flavor.SCANNABLE;  <br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>        flavor = CsvTable.Flavor.valueOf(flavorName.toUpperCase(Locale.ROOT));  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CsvSchema(directoryFile, flavor);  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>在模型的驱动下，模式工厂实例化一个名为 <code>SALES</code> 的单模式。该模式是<a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/main/example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvSchema.java">org.apache.calcite.adapter.csv.CsvSchema</a> 的一个实例，并实现 calcite <a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/schema/Schema.html">Schema</a> 接口。</p>
<p>模式的一项工作是生成一系列的表（它还可以生成子模式和表函数，但这些是高级功能，<code>calcite-example-csv</code> 不支持它们）。这些表实现了 Calcite <a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/schema/Table.html">Table</a> 接口。<code>CsvSchema</code> 生成的表是  <a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/main/example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvTable.java">CsvTable</a> 及其子类的实例。</p>
<p>下面是 <code>CsvSchema</code> 的相关代码，它重写了 <code>AbstractSchema</code> 基类中的 <a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/schema/impl/AbstractSchema.html#getTableMap(">getTableMap()</a>) 方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Map&lt;String, Table&gt; <span class="hljs-title">createTableMap</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-comment">// Look for files in the directory ending in &quot;.csv&quot;, &quot;.csv.gz&quot;, &quot;.json&quot;,  </span><br>    <span class="hljs-comment">// &quot;.json.gz&quot;.    final Source baseSource = Sources.of(directoryFile);  </span><br>    File[] files = directoryFile.listFiles((dir, name) -&gt; &#123;  <br>        <span class="hljs-keyword">final</span> String nameSansGz = trim(name, <span class="hljs-string">&quot;.gz&quot;</span>);  <br>        <span class="hljs-keyword">return</span> nameSansGz.endsWith(<span class="hljs-string">&quot;.csv&quot;</span>)  <br>                || nameSansGz.endsWith(<span class="hljs-string">&quot;.json&quot;</span>);  <br>    &#125;);  <br>    <span class="hljs-keyword">if</span> (files == <span class="hljs-keyword">null</span>) &#123;  <br>        System.out.println(<span class="hljs-string">&quot;directory &quot;</span> + directoryFile + <span class="hljs-string">&quot; not found&quot;</span>);  <br>        files = <span class="hljs-keyword">new</span> File[<span class="hljs-number">0</span>];  <br>    &#125;  <br>    <span class="hljs-comment">// Build a map from table name to table; each file becomes a table.  </span><br>    <span class="hljs-keyword">final</span> ImmutableMap.Builder&lt;String, Table&gt; builder = ImmutableMap.builder();  <br>    <span class="hljs-keyword">for</span> (File file : files) &#123;  <br>        Source source = Sources.of(file);  <br>        Source sourceSansGz = source.trim(<span class="hljs-string">&quot;.gz&quot;</span>);  <br>        <span class="hljs-keyword">final</span> Source sourceSansJson = sourceSansGz.trimOrNull(<span class="hljs-string">&quot;.json&quot;</span>);  <br>        <span class="hljs-keyword">if</span> (sourceSansJson != <span class="hljs-keyword">null</span>) &#123;  <br>            <span class="hljs-keyword">final</span> Table table = <span class="hljs-keyword">new</span> JsonScannableTable(source);  <br>            builder.put(sourceSansJson.relative(baseSource).path(), table);  <br>        &#125;  <br>        <span class="hljs-keyword">final</span> Source sourceSansCsv = sourceSansGz.trimOrNull(<span class="hljs-string">&quot;.csv&quot;</span>);  <br>        <span class="hljs-keyword">if</span> (sourceSansCsv != <span class="hljs-keyword">null</span>) &#123;  <br>            <span class="hljs-keyword">final</span> Table table = createTable(source);  <br>            builder.put(sourceSansCsv.relative(baseSource).path(), table);  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> builder.build();  <br>&#125;  <br>  <br><span class="hljs-comment">/** Creates different sub-type of table based on the &quot;flavor&quot; attribute. */</span>  <br><span class="hljs-function"><span class="hljs-keyword">private</span> Table <span class="hljs-title">createTable</span><span class="hljs-params">(Source source)</span> </span>&#123;  <br>    <span class="hljs-keyword">switch</span> (flavor) &#123;  <br>        <span class="hljs-keyword">case</span> TRANSLATABLE:  <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CsvTranslatableTable(source, <span class="hljs-keyword">null</span>);  <br>        <span class="hljs-keyword">case</span> SCANNABLE:  <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CsvScannableTable(source, <span class="hljs-keyword">null</span>);  <br>        <span class="hljs-keyword">case</span> FILTERABLE:  <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CsvFilterableTable(source, <span class="hljs-keyword">null</span>);  <br>        <span class="hljs-keyword">default</span>:  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(<span class="hljs-string">&quot;Unknown flavor &quot;</span> + <span class="hljs-keyword">this</span>.flavor);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>模式扫描目录，找到所有具有适当扩展名的文件，并为它们创建表。在这种情况下，目录是 <code>sales</code>，包含文件 <code>EMPS.csv.gz</code>、<code>DEPTS.csv</code> 和 <code>SDEPTS.csv</code> ，这些文件成为表<code>EMPS</code>、<code>DEPTS</code>和<code>SDEPTS</code>。</p>
<h3 id="模式中的表和视图"><a href="#模式中的表和视图" class="headerlink" title="模式中的表和视图"></a>模式中的表和视图</h3><p>请注意，我们不需要在模型中定义任何表;架构 自动生成表。</p>
<p>您可以定义额外的表， 除了那些自动创建的， 使用架构的属性。<code>tables</code></p>
<p>让我们看看如何创建 一种重要且有用的表类型，即视图。</p>
<p>在编写查询时，视图看起来像一个表，但它不存储数据。 它通过执行查询来派生其结果。 在规划查询时，视图会展开，因此查询优化器通常可以执行优化，删除那些在最终结果中未使用的 SELECT 子句表达式。</p>
<p>下面是定义视图的架构：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  version: &#x27;1.0&#x27;,<br>  defaultSchema: &#x27;SALES&#x27;,<br>  schemas: [<br>    &#123;<br>      name: &#x27;SALES&#x27;,<br>      type: &#x27;custom&#x27;,<br>      factory: &#x27;org.apache.calcite.adapter.csv.CsvSchemaFactory&#x27;,<br>      operand: &#123;<br>        directory: &#x27;sales&#x27;<br>      &#125;,<br>      tables: [<br>        &#123;<br>          name: &#x27;FEMALE_EMPS&#x27;,<br>          type: &#x27;view&#x27;,<br>          sql: &#x27;SELECT * FROM emps WHERE gender = \&#x27;F\&#x27;&#x27;<br>        &#125;<br>      ]<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p><code>&quot;type&quot;: &quot;view&quot;</code> 这行将 <code>FEMALE_EMPS</code> 标记为视图，而不是常规表或自定义表。JSON 并不能简单地书写长字符串，因此 Calcite 支持另一种可选的语法。如果你的视图有很长的 SQL 语句，你可以将单个字符串改为多行列表<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  name: &#x27;FEMALE_EMPS&#x27;,<br>  type: &#x27;view&#x27;,<br>  sql: [<br>    &#x27;SELECT * FROM emps&#x27;,<br>    &#x27;WHERE gender = \&#x27;F\&#x27;&#x27;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><br>现在，我们已经定义了一个视图，我们可以像使用表一样，在查询中使用它：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">sqlline&gt;</span><span class="bash"> SELECT e.name, d.name FROM female_emps AS e JOIN depts AS d on e.deptno = d.deptno;</span><br>+--------+------------+<br>|  NAME  |    NAME    |<br>+--------+------------+<br>| Wilma  | Marketing  |<br>+--------+------------+<br></code></pre></td></tr></table></figure></p>
<h3 id="自定义表"><a href="#自定义表" class="headerlink" title="自定义表"></a>自定义表</h3><p>自定义表是那些由用户自定义的代码驱动的表。他们不需要存在于自定义模式中。</p>
<p>在 <code>model-with-custom-table.json</code> 模型文件中，有一个自定义表的例子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  version: &#x27;1.0&#x27;,<br>  defaultSchema: &#x27;CUSTOM_TABLE&#x27;,<br>  schemas: [<br>    &#123;<br>      name: &#x27;CUSTOM_TABLE&#x27;,<br>      tables: [<br>        &#123;<br>          name: &#x27;EMPS&#x27;,<br>          type: &#x27;custom&#x27;,<br>          factory: &#x27;org.apache.calcite.adapter.csv.CsvTableFactory&#x27;,<br>          operand: &#123;<br>            file: &#x27;sales/EMPS.csv.gz&#x27;,<br>            flavor: &quot;scannable&quot;<br>          &#125;<br>        &#125;<br>      ]<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>我们可以使用常规的方式查询自定义表：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">sqlline&gt;</span><span class="bash"> !connect jdbc:calcite:model=src/<span class="hljs-built_in">test</span>/resources/model-with-custom-table.json admin admin</span><br><span class="hljs-meta">sqlline&gt;</span><span class="bash"> SELECT empno, name FROM custom_table.emps;</span><br>+--------+--------+<br>| EMPNO  |  NAME  |<br>+--------+--------+<br>| 100    | Fred   |<br>| 110    | Eric   |<br>| 110    | John   |<br>| 120    | Wilma  |<br>| 130    | Alice  |<br>+--------+--------+<br></code></pre></td></tr></table></figure></p>
<p>该模式是一个常规的模式，包含一个由<a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/main/example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvTableFactory.java">org.apache.calcate.adapter.csv.CsvTableFactory</a>提供支持的自定义表，实现Calcite接口<a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/schema/TableFactory.html">TableFactory</a>. 它的方法实例化，从模型文件中传入参数:<code>create</code> <code>CsvScannableTable</code> <code>file</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> CsvTable <span class="hljs-title">create</span><span class="hljs-params">(SchemaPlus schema, String name,  </span></span><br><span class="hljs-function"><span class="hljs-params">                       Map&lt;String, Object&gt; operand, <span class="hljs-meta">@Nullable</span> RelDataType rowType)</span> </span>&#123;  <br>    String fileName = (String) operand.get(<span class="hljs-string">&quot;file&quot;</span>);  <br>    <span class="hljs-keyword">final</span> File base =  <br>            (File) operand.get(ModelHandler.ExtraOperand.BASE_DIRECTORY.camelName);  <br>    <span class="hljs-keyword">final</span> Source source = Sources.file(base, fileName);  <br>    <span class="hljs-keyword">final</span> RelProtoDataType protoRowType =  <br>            rowType != <span class="hljs-keyword">null</span> ? RelDataTypeImpl.proto(rowType) : <span class="hljs-keyword">null</span>;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CsvScannableTable(source, protoRowType);  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>实现自定义表，通常是实现自定义模式的一个更简单方法。这两种方法可能最终都会创建类似的 <code>Table</code> 接口实现，但对于自定义表，你不需要实现元数据发现。<code>CsvTableFactory</code> 创建一个 <code>CsvScannableTable</code>，就像 <code>CsvSchema</code> 所做的那样，但表的实现不会扫描文件系统来查找 <code>.csv</code> 文件。</p>
<p>自定义表需要模型的开发者做更多的工作，需要明确指定每个表及其文件，但也给开发者提供了更多的控制权，例如，为每个表提供不同的参数。</p>
<h3 id="模型中的注释"><a href="#模型中的注释" class="headerlink" title="模型中的注释"></a>模型中的注释</h3><p>模型可以使用 <code>/* ... */</code> 和 <code>//</code> 语法来包含注释：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  version: &#x27;1.0&#x27;,<br>  <span class="hljs-comment">/* Multi-line</span><br><span class="hljs-comment">     comment. */</span><br>  defaultSchema: &#x27;CUSTOM_TABLE&#x27;,<br>  <span class="hljs-comment">// Single-line comment.</span><br>  schemas: [<br>    ..<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>注释不是标准的 JSON，而是一种无害的扩展。</p>
<h3 id="使用优化器规则优化查询"><a href="#使用优化器规则优化查询" class="headerlink" title="使用优化器规则优化查询"></a>使用优化器规则优化查询</h3><p>我们到目前为止看到的表实现都不错,只要表不包含大量的数据。但是,如果您的客户表有 100 列和 100 万行,您会更喜欢系统在每个查询中不检索所有数据。您希望 Calcite 与适配器协商并找到一种更有效的访问数据的方式。</p>
<p>这种协商是查询优化的一种简单形式。Calcite 通过添加 <em>优化器规则</em> 来支持查询优化。优化器规则的工作方式是在查询解析树中查找模式(例如某种表解析树顶部的投影),并用一组新的节点替换匹配的节点来实现优化。</p>
<p>优化器规则也是可扩展的,就像 schema 和表一样。因此,如果您有一个想通过 SQL 访问的数据存储,您首先要定义一个自定义表或 schema,然后定义一些规则来进行高效访问。</p>
<p>要查看它的实际操作,我们使用一个规划器规则来访问 CSV 文件中的一部分列。让我们对两个非常相似的 schema 运行相同的查询:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">sqlline&gt;</span><span class="bash"> !connect jdbc:calcite:model=src/<span class="hljs-built_in">test</span>/resources/model.json admin admin</span><br><span class="hljs-meta">sqlline&gt;</span><span class="bash"> explain plan <span class="hljs-keyword">for</span> select name from emps;</span><br>+-----------------------------------------------------+<br>| PLAN                                                |<br>+-----------------------------------------------------+<br>| EnumerableCalc(expr#0..9=[&#123;inputs&#125;], NAME=[$t1])    |<br>|   EnumerableTableScan(table=[[SALES, EMPS]])        |<br>+-----------------------------------------------------+<br><span class="hljs-meta">sqlline&gt;</span><span class="bash"> !connect jdbc:calcite:model=src/<span class="hljs-built_in">test</span>/resources/smart.json admin admin</span><br><span class="hljs-meta">sqlline&gt;</span><span class="bash"> explain plan <span class="hljs-keyword">for</span> select name from emps;</span><br>+-----------------------------------------------------+<br>| PLAN                                                |<br>+-----------------------------------------------------+<br>| CsvTableScan(table=[[SALES, EMPS]], fields=[[1]])   |<br>+-----------------------------------------------------+<br></code></pre></td></tr></table></figure></p>
<p>是什么导致了执行计划的差异？让我们跟着证据的线索走。在 <code>smart.json</code> 模型文件中，只有一行：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">flavor: &quot;translatable&quot;<br></code></pre></td></tr></table></figure></p>
<p>这个配置会使用 <code>flavor = TRANSLATABLE</code> 来创建 <code>CsvSchema</code>，它的 <code>createTable</code> 方法创建了 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/main/example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvTranslatableTable.java">CsvTranslatableTable</a> 而不是 <code>CsvScannableTable</code>。</p>
<p><code>CsvTranslatableTable</code> 实现了 <a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/schema/TranslatableTable.html#toRel(">TranslatableTable.toRel()</a>) 方法，用来创建 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/main/example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvTableScan.java">CsvTableScan</a>。表扫描是查询操作树的叶子节点。通常实现是 <a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/adapter/enumerable/EnumerableTableScan.html">EnumerableTableScan</a>，但我们创建了一个独特的子类型，它将导致规则触发。</p>
<p>下面是完整的规则实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CsvProjectTableScanRule</span></span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">RelRule</span>&lt;<span class="hljs-title">CsvProjectTableScanRule</span>.<span class="hljs-title">Config</span>&gt; </span>&#123;<br><br>  <span class="hljs-comment">/** Creates a CsvProjectTableScanRule. */</span><br>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">CsvProjectTableScanRule</span><span class="hljs-params">(Config config)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(config);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMatch</span><span class="hljs-params">(RelOptRuleCall call)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> LogicalProject project = call.rel(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">final</span> CsvTableScan scan = call.rel(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span>[] fields = getProjectFields(project.getProjects());<br>    <span class="hljs-keyword">if</span> (fields == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-comment">// Project contains expressions more complex than just field references.</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    call.transformTo(<br>        <span class="hljs-keyword">new</span> CsvTableScan(<br>            scan.getCluster(),<br>            scan.getTable(),<br>            scan.csvTable,<br>            fields));<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] getProjectFields(List&lt;RexNode&gt; exps) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] fields = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[exps.size()];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; exps.size(); i++) &#123;<br>      <span class="hljs-keyword">final</span> RexNode exp = exps.get(i);<br>      <span class="hljs-keyword">if</span> (exp <span class="hljs-keyword">instanceof</span> RexInputRef) &#123;<br>        fields[i] = ((RexInputRef) exp).getIndex();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <span class="hljs-comment">// not a simple projection</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fields;<br>  &#125;<br><br>  <span class="hljs-comment">/** Rule configuration. */</span><br>  <span class="hljs-meta">@Value</span>.Immutable(singleton = <span class="hljs-keyword">false</span>)<br>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Config</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RelRule</span>.<span class="hljs-title">Config</span> </span>&#123;<br>    Config DEFAULT = ImmutableCsvProjectTableScanRule.Config.builder()<br>        .withOperandSupplier(b0 -&gt;<br>            b0.operand(LogicalProject.class).oneInput(b1 -&gt;<br>                b1.operand(CsvTableScan.class).noInputs()))<br>        .build();<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">default</span> CsvProjectTableScanRule <span class="hljs-title">toRule</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CsvProjectTableScanRule(<span class="hljs-keyword">this</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>规则的默认实例驻留在 <code>CsvRules</code> 的持有类中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CsvRules</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> CsvProjectTableScanRule PROJECT_SCAN =<br>      CsvProjectTableScanRule.Config.DEFAULT.toRule();<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h2 id="代数"><a href="#代数" class="headerlink" title="代数"></a>代数</h2>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/calcite/">calcite</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/calcite/">calcite</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/02/25/%E5%85%B6%E4%BB%96/mybatis%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E6%95%B0%E6%8D%AE%E6%BA%90/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">mybatis支持多种数据源</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/02/04/%E7%AE%97%E6%B3%95/1686-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8FVI/">
                        <span class="hidden-mobile">1686-石子游戏VI</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
